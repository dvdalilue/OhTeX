\documentclass[12pt,letterpaper,titlepage,oneside,openright]{book}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[svgnames]{xcolor}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{lettrine}
\usepackage{listings}
\usepackage{relsize}
\usepackage{xspace}
%\usepackage{tabularx}
%\usepackage{booktabs}
%\usepackage{cleveref}
%\usepackage{microtype}
%\usepackage{geometry}
%\usepackage{nag}
%\usepackage{siunitx}

\newcommand{\OhTeX}{%
    \makebox[0.76em][c]{O}%
    \makebox[0.25em][c]{%
        \raisebox{0.14em}[0em][0em]{%
            \fontsize{0.5em}{0cm}%
                \selectfont H%
        }%
    }%
    \makebox[1.35em][c]{\TeX}%
}

% Change title of every code listing
\renewcommand*\lstlistingname{Código}
% Code listing options
\lstset{
basicstyle=\footnotesize\ttfamily,
%numbers=left,
%numberstyle=\scriptsize,
%numbersep=1pt,
belowskip=\medskipamount,
frame = trBL,%single,
framexleftmargin=15pt,
literate={á}{{\'a}}1 {í}{{\'i}}1 {é}{{\'e}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1,
}

\renewcommand*\rmdefault{ptm} % Times Font
\renewcommand{\labelitemi}{$\bullet$} % List symbol

% Add a space a the end of the original logo
\newcommand{\latex}{\LaTeX\xspace}
\newcommand{\tex}{\TeX\xspace}
\newcommand{\ohtex}{\OhTeX\xspace}
\newcommand{\ruby}{\textit{Ruby}\xspace}
\newcommand{\lyx}{\textit{LyX}\xspace}

% Reduce hyphenation
\hyphenpenalty 1000
\exhyphenpenalty 1000

\setlength{\parindent}{3em} % First line paragraph indentation
\setlength{\parskip}{2em} % Paragraph spacing
\renewcommand{\baselinestretch}{1.3} % Line spacing
%1.0    single spacing
%1.3    one-and-a-half spacing
%1.6    double spacing

\setcounter{chapter}{0} % Chapter begins on chapter -1

\newcommand{\nonumberchapter}[1]{
    \chapter*{#1}
    \addcontentsline{toc}{chapter}{#1}
}

\newcommand{\myref}[5]{
    #1. #2. #3. Disponible en Internet: #4, consultado el #5.

% Huerta, Ana. 2003. El gabinete de Historia Natural de Puebla. Disponible en Internet: http://www.elementos.buap.mx/num48/htm/17.htm, consultado el 25 de Abril de 2008.
}

\newcommand{\ttcode}[1]{(\texttt{#1})}

%\title{\ohtex \ : Un lenguaje de programación orientado a objetos destinado a la composición tipográfica}
%\author{Lilue, David}

\begin{document}

\frontmatter

\begin{titlepage}
    \begin{center}
        \noindent
        \includegraphics[width=0.15\textwidth]{book_design/logo}\\
        {\large UNIVERSIDAD SIMÓN BOLIVAR}\\
        DECANATO DE ESTUDIOS PROFESIONALES\\
        COORDINACIÓN DE INGENIERIA DE LA COMPUTACIÓN
        
        %\vspace{4cm}
        \vspace{3em}
        %\ohtex \\
        \textbf{Un lenguaje de programación orientado a objetos destinado a la composición tipográfica}
        
        %\LARGE
        %Thesis Subtitle
        
        %\vspace{1.5cm}
        \vspace{2em}
        Por:\\
        David Alejandro Lilue Borrero\\
        
        \vspace{3em}
        %\vspace{1.5cm}
        Realizado con la asesoría de:\\
        Ricardo Monascal\\

        %\vfill
        \vspace{4em}
        %\vspace{1.5cm}
        PROYECTO DE GRADO\\
        Presentado ante la Ilustre Universidad Simón Bolivar\\
        como requisito parcial para optar al título de\\
        Ingeniero de la Computación\\
        
        %\vspace{0.8cm}
        \vfill
        
        \today
        
    \end{center}
\end{titlepage}

%\maketitle

\nonumberchapter{Preámbulo}

\section*{Resumen}

\lettrine[lines=2]{D}{}\ urante la década de los $70'$ se creó un lenguaje llamado \textit{troff} qué fue inspirado por
runoff, el primer programa para el formato de texto qué fue desarrollado a mediados
de los 60'. \textit{troff} posee la cualidad de de indicar fuente, espaciados,
párrafos, márgenes, pie de páginas, posicionar caracteres de manera arbitraria en las
páginas, superponerlas, entre otras cosas. Aunque hoy en día existen lenguajes para
la composición tipográfica que son comúnmente usados, como \LaTeX \ y otros lenguajes de
markup, este sigue siendo usado ampliamente para la documentación de UNIX. Por otro
lado en los años 90' se re-implementado como \textit{groff} por los sistemas GNU, por
cuestiones de software libre. 

Un aspecto importante, es para quién está destinado este lenguaje de composición
tipográfica, es decir, para una comunidad científica y de investigación, para la
comunidad literaria, para una comunidad administrativa y/o gerencial o todas? 

Existen muchos lenguajes de Markup, unos que son simples, otros que son más
complejos, así como \textit{markdown} y \LaTeX, respectivamente. Uno trata de
simplificar y el otro trata de generar un documento enfocado en la belleza. Tomando
en cuenta que se desea la posibilidad de generar documentos similares a los de latex,
pero que sea tan sencillo cómo un lenguaje de markup ligero (LML). Dándole un punto
de vista más estructural y abstracto, haciendo uso de la orientación a objetos.

La idea con este lenguaje es poder manejar de una manera abstracta y simple, los
elementos de un documento así como su composición tipográfica en el documento final
generado. Por lo tanto, será posible usar estructuras de control para generar
distintos documentos a partir de objetos y estructuras abstractas.

% Por ejemplo, agarrar una plantilla con espacios vacíos iterar sobre una lista de
% objetos dónde cada objeto llene de manera diferente y sus espacios vacíos. Sería
% como una meta programación de documentos.

\newpage
 
%\addcontentsline{toc}{chapter}{Dedicatoria}
\section*{} % Dedicatoria
\begin{flushright}
Para todos esos artistas que dejaron su obra, \\ sin su nombre y aun así trascendieron.
\end{flushright}

\newpage

%\addcontentsline{toc}{chapter}{Agradecimientos}
\section*{} % Agradecimientos
\begin{flushleft}
Agradezco a un perro de papel \\
que algunos dicen que esta perdido, \\
mas no quiere ser encontrado.
\end{flushleft}

\newpage

\tableofcontents

\mainmatter

%\thispagestyle{empty} % Removes the page numbering.

%\listoffigures

%\pagebreak
 
%\listoftables
 
%\newpage

%\pagenumbering{arabic} % Re-start the page numbering with arabic style.

%\chapter{Motivación}
\chapter{Introducción}

En este trabajo se expone el proceso evolutivo de la composición tipográfica, así como sus componentes. Hoy en día, el lenguaje mas usado para la generación de documentos de índole académica y de investigación, es \latex; hasta el momento tiene 30 años siendo el mejor y posiblemente le queden varios. La intención de este trabajo no es crear un nuevo sistema de composición tipográfica, porque \tex/\latex lo hace muy bien; el propósito es demostrar un concepto, que es posible elevar el nivel de abstracción sin perder la parte esencial y flexible de \tex/\latex. Haciendo uso de un sistema de objetos, que abstraiga los elementos de un documento a tipos de datos abstractos con atributos que le den formato al texto, ademas de ilustrar una estructuración mas perceptible y fácil de manejar, sin la necesidad de marcas (\textit{tags}); las cuales requieren tiempo para escribir y dificultan el aprendizaje del lenguaje. En cambio, es posible marcar contenido por medio de clases y atributos.

%\section*{Antecedentes}

%\subsection*{Linea de Tiempo}

%\begin{itemize}

%\item 1971, Graphic Systems designs and markets the C/A/T phototypesetter.
%\item 1972, Graphic Systems provides a simple computer front end to handle display typesetting from text input using a standard set of fonts.
%\item 1973, Bell Laboratories purchases a GSI C/A/T phototypesetter for their UNIX software development team.
%\item 1973, The troff software was created by Joe F. Ossanna at Bell Labs.
%\item 1974, Graphic Systems partners with Singer Corporation to market the GSI C/A/T phototypesetter. Singer Corporation was allowed to put the Singer C/A/T logo on equipment they sold.
%\item 1978, Singer Corporation gets out of the typesetting business.
%\item 1978, Wang Laboratories purchases Graphic Systems and continued to market the GSI C/A/T typesetter. for UNIX based phototypesetting. The phototypesetter was then known as the Wang Graphic Systems C/A/T. This allowed the phototypesetter to be available through the 1980s.
%\item 1979, ditroff software was created by Brian Kernighan.
%\item 1979, TeX software was created by Donald E. Knuth.
%\item 1981-1983, LaTeX software was created by Leslie Lamport.
%\item 1992, Wang Laboratories declared Chapter 11 bankruptcy.
%\end{itemize}

%\subsection*{\textit{troff}}
%\subsection*{\TeX}
%\subsection*{\LaTeX}
%\subsection[OhTeX]{\ohtex}

\chapter{Marco Teórico}
\section{Composición Tipográfica (\textit{Typesetting})}

La composición tipográfica se define como la organización de caracteres de imprenta (\textit{types}) o su equivalente en digital. Se componen letras, símbolos y glifos acorde a la ortografía de un lenguaje, junto a la gramática y al final, obtener la visualización de un texto.

Este término se maneja desde alrededores del año 1040, empleando piezas movibles hechas de cerámica en China, luego en 1377, se usan \textit{types} metálicos que fueron inventados en Korea, durante la dinastía \textit{Koryo} y usados mas que todo para la impresión de documentos budistas, \textit{Jikji} (el libro mas viejo impreso con \textit{types} metálicos) pero ya se había desarrollado esa tecnología en 1234. Posteriormente, llegó a occidente alrededor del 1440 y era usada principalmente para cartas.

Durante el proceso, cada \textit{type} era una pieza metálica (o de cerámica) con un carácter en relieve sobre uno de los lados, estos se colocaba a mano (uno a uno) para crear palabras, luego oraciones, párrafos, páginas y al final, se imprimía una página colocando tinta encima del conjunto de \textit{types} y presionando el papel sobre el mismo. Obviamente todos los caracteres debían estar invertidos para que en el papel se imprimiese bien orientado.

En el año 1884, \textit{Ottmar Mergenthaler}; quien fundo \textit{The Mergenthaler Linotype Company}, desarrollo una maquina llamada, maquina linotipia (\textit{Linotype Machine}) destinada para la imprenta, facilitando la alineación de \textit{types} de una manera rápida y sencilla. Para alrededores del 1914, ya tenia un competidor, \textit{The Intertype Company} que uso el mismo concepto, usando otros materiales en su maquina (acero y aluminio).

Para el siglo 19, se había globalizado e industrializado esta forma de impresión, mas que todo por imprentas y editoriales. Pero esto fue hasta los 1970s y 1980s, dado que fueron sustituidas por una nueva tecnología llamada foto-composición tipográfica (\textit{Phototypesetting}), que computarizaron este concepto. Su mayor impacto, fue que estas maquinas podían ser usadas en oficinas, mientras que la otras no.

El proceso era mas simple, se imprimían caracteres en un negativo o un papel sensible a la luz para su posterior impresión. También se incorporó el uso de programas mas complejos para la composición tipográfica electrónica como \textit{troff}, que generaban la entrada de un foto-componedor tipográfico \textit{phototypesetter} (\textit{Graphic System CAT}).

A pesar de su innovación, se convirtió rápidamente en un método obsoleto gracias a que se hizo posible generar una salida de los se iba componiendo en un tubo de rayos catódicos, imprimiendo en una imagen digital. Y posteriormente, en 1985 se podía hacer uso de programas destinados a la publicación de escritorio (\textit{Desktop Publishing [DTP]}) y combinándolo con \textit{PostScript}.

En paralelo, en el año 1978 aparece \tex, un lenguaje para la composición tipográfica para que cualquiera, con un razonable mínimo de esfuerzo, pueda generar un documento o libros y que iba a funcionar en cualquier computador. Este desplazo ampliamente a \textit{troff}, que había mejorado al incorporar otras salidas que no fuesen un \textit{phototypesetter}, como impresoras y \textit{PostScript} pero las capacidades de mismo fueron superadas. Más tarde, en el año 1985, aparece un macro paquete, \latex para reducir la dificultad que presentaba aprender \tex.

Cabe destacar que herramientas de \textit{Desktop Publishing} es diferente a lo que serian \tex/\latex y \textit{troff} dado que no brindan una interfaz gráfica con una filosofía \textit{WYSIWYG}.

\section{Programación orientada a objetos (\textit{OOP})}

La orientación a objetos es un paradigma basado en objetos, estructuras de datos que contienen atributos y bloques de código, conocidos como métodos. Una característica distintiva dentro de este paradigma es que un método de un objeto puede acceder y/o modificar atributos de si mismo, es decir, referencirse a si mismo usando la notación de \textit{self} o \textit{this}.

La idea de este concepto es elevar el nivel de abstracción, al momento de representar problemas de la vida real en algoritmos y estructuras de datos. Permitiendo al programador enfocarse en el problema, mas que su representación. Muchos lenguajes incorporan ciertas características de este paradigma a su diseño y otros un sistema de objetos puro, donde todo el lenguaje es un objeto y todo objeto es una instancia de una clase.

En este paradigma hay dos conceptos esenciales, las clases; que es la definición de un conjunto de datos y comportamientos, y las objetos; que son las instancias de las clases. Los mismos pueden tener métodos, atributos, campos o miembros. Y existen una distinción en cuanto a la información contenida por los objetos:

\begin{itemize}
    \item Variables de clase. Pertenece a la clase, es decir, que solo existe una y podría ser accedido desde una instancia.
    \item Variables de instancia. Pertenece individualmente a cada objeto (instancia) de una clase con un valor particular para cada uno.
    \item Métodos de clase. Pertenece a la clase y solo puede acceder a las variables de clase y parámetros que sean pasados al método.
    \item Métodos de instancia. Pertenece individualmente a cada objeto (instancia) de una clase. Y solo tiene acceso a las variables de la instancia desde donde es llamado, así como a los parámetros que se le pasan.
\end{itemize}

Un concepto intrínseco en la programación orientada a objetos y de gran importancia en cuanto a la abstracción, que es el encapsulamiento. Que nos habla de ocultar información, esto útil porque evita que código externo se preocupe del funcionamiento de un objeto y al momento de refactorizar código.

Objetos pueden contener otros objetos de distinta clases dentro de sus atributos y crear una relación entre instancias. Por otro lado, la relación mas fuerte entre objeto, es la herencia; en la mayoría de las veces, cuando un lenguaje tiene clases, tiene herencia. Si se vieran a las clases como conjuntos, una sub-clase sería un sub-conjunto.

La herencia de clases en los lenguajes orientados a objetos puede ser simple o múltiple, y esa decisión queda a discreción de su creador. Uno de los problemas de los mayores problemas de la herencia múltiple, es que padres de una clase pueden ser sub-clases de un mismo padre y esto generaría colisiones en mi nueva clase, esto se le conoce como el problema del diamante y los lenguajes atacan ese problema de distintas formas. En el caso de la herencia simple, no ocurre este problema, pero ``perderían'' poder y usan otras estrategias para compensarlo; haciendo uso de mixins, interfaces, clases abstractas, etc.

Los lenguajes que incorporan este concepto a su diseño, lenguajes como Java y C++ usan conceptos de clases, herencia, atributos, métodos, instancias, interfaces, etc; siguen siendo imperativos y otros como Scala, son declarativos. Así, que no van en función de como se programa.

\section{Lenguajes de Marcado (\textit{Markup})}

Estos lenguajes ofrecen un sistema que permite explicar y realizar anotaciones en un documento, sin que se mezcle con el contenido. Para ello, la mayoría de los lenguajes usan marcas (o \textit{tags}). Uno de los mas conocido es \textit{HTML}, que es mundialmente usado y es un ejemplo que sigue los estándares generalizados de los lenguajes de marcado (\textit{SGML}), en su mayor parte.

Dentro de estos lenguajes existen distintas formas de marcar el texto y categorías:

\paragraph{Marcado por presentación}

Es usado por sistemas para el procesamiento de texto, siguiendo el paradigma \textit{WYSIWYG}, donde todo el proceso de marcado esta oculto para quien el usuario, es decir, se hace directamente en la maquina.

\paragraph{Marcado procedural}

El marcado esta integrado con el texto, mientras provee instrucciones para el procesamiento del texto en el lenguaje. Todo es visible y manipulable por el usuario. Este tipo de marcado ofrece procedimientos, métodos o macros que permiten manipular el texto.

\paragraph{Marcado descriptivo}

En este caso, los lenguajes ofrecen la posibilidad de indicar como debería ser procesado el texto, en vez de hacerlo. Para separar la estructura del texto, y sea independiente de su interpretación al momento de procesarlo.

Claramente, la mayoría de los lenguajes de marcado no se encasillan en alguna categoría específicamente. Por ejemplo, \tex siendo un lenguaje de marcado procedural, se le dio un enfoque mas descriptivo con \latex.

El primer lenguaje que uso este concepto, de separar la presentación del texto de su contenido, fue \textit{Scribe}. Ahora, en el caso del marcado descriptivo, la presentación queda por parte de otro lenguaje, programa, etc. \textit{HTML}, se usa comúnmente junto a \textit{CSS}, que es una ``hoja de estilo'' y describe la presentación de un documento.

\subsection{Lenguajes Ligeros de Marcado}

En los últimos años han surgido lenguajes de marcado, mas sencillos, fácil de entender y escribir en cualquier ambiente.  Algunos no usan \textit{tags} explícitamente, y se enfocan en el contenido; que el mismo pueda ser leído con facilidad sin pasar por un procesador de texto y darle una presentación humana.

Uno de los mas usados, es \textit{Markdown} y es fácilmente de escribir en cualquier editor de texto. Pero la única desventaja de este tipo de lenguajes, es que no brindan muchas posibilidades para generar documentos, se enfocan principalmente en el contenido.

\section{Serialización de datos}

La serialización es el proceso de traducir estructuras y objetos en un formato especifico para que pueda ser transmitido por algún medio y que pueda ser reconstruido independientemente del ambiente o entorno (deserialización).

Es comúnmente usado para transferir datos por redes, entre distintas herramientas, guardar información, etc. Es una manera de guardar información en un formato estándar y que puede ser interpretado dependiendo de quien lea los datos.

En el caso de tipos abstractos de datos, que posean información privada o protegida, es decir, encapsulamiento; la serialización podría violar ese concepto al momento de serializar toda la información.

Existen tres lenguajes bastante usados para la transmisión de datos y su serialización:

\begin{itemize}
    \item \textit{XML}. Es un lenguaje de marcado, para transmitir información entre lenguajes y que seguía siendo humanamente leible.
    \item \textit{JSON}. Es una versión mas simple, que almacena la información en objetos, usando una notación de pares; atributo-valor. 
    \item \textit{YAML}. Posee mas cualidades que \textit{JSON}, por lo que lo hace mas poderoso y esta diseñado para que sea mas amigable al momento de leer la información.
\end{itemize}

\section{Lenguajes de dominio específico (\textit{DSLs})}

Una definición simple de los que son este tipo de lenguajes, es que están diseñados para abarcar un problema específico. Existen muchos lenguajes que son usados comúnmente sin saber que son de dominio especifico, como \textit{awk}, \textit{make}, \textit{HTML}, inclusive \textit{troff}. En contraste a los lenguajes de propósito general (\textit{GPL}), que son aplicables en cualquier área. En el diseño de un lenguaje de dominio especifico, se debe tomar una decisión en cuanto a si será interno o externo.

\paragraph{\textit{DLS} Interno}

Este tipo de lenguajes forman parte de un lenguaje anfitrión para apoyar sus funcionalidades, diseñan una modelo de uso; pudiendo llamarse lenguajes embebidos o ser simplemente una librería del un \textit{GPL}.

\paragraph{\textit{DLS} Externo.}

Estos lenguajes tienen su propia sintaxis, poseen un parser completo. Pero mantienen la idea de enfocarse en un problema especifico.

Por otro lado, al momento de diseñar un \textit{DLS} existen patrones:

\begin{itemize}
    \item Una herramienta independiente. (\textit{make}, \textit{grep}).
    \item Un sistema de macros en el lenguaje anfitrión. (\latex.)
    \item Un lenguaje embebido o librería. (\textit{OpenGL})
    \item Un lenguajes para una funcionalidad de un \textit{GPL}, que pueden ser operaciones en el mismo. (Expresiones regulares)
\end{itemize}

Este tipo de lenguajes incorporan mayor nivel de abstracción y expresividad en cuanto al problema que abarca. Por otro lado, el costo de aprender un nuevo lenguaje en relación a sus capacidades podría llegar a ser una desventaja y si hay una implementación en un nivel alto, podría costar en el desempeño pero la eficiencia va en relación a los requerimientos del lenguaje.

\chapter{Marco Tecnológico}

\section{\tex/\latex}

\tex es un sistema destinado a la composición tipográfica, diseñado por \textit{Donald Knuth}. Y ha sido categorizado como la mejor herramienta tipográfica (digital) hasta el momento, la misma es usada comúnmente en el ámbito académico para la generación de libros, artículos y publicaciones; mas que todo el área de matemáticas, ciencias de la computación, ingeniería, física y estadística. Siempre cuando se requiera crear un documento de investigación.

En el momento que salió este lenguaje, en el 1978, fue la principal competencia de \textit{troff}, el primer sistema de composición tipográfica y dado que incorporaba aspectos que para el momento, se hacían con muchos error o no se hacían, desplazo al mismo rápidamente. Ademas de generar una composición de calidad, usa algoritmos para el espaciado de ecuaciones, justificación de texto y separación de palabras \textit{hyphenation}; que en su momento fueron innovadores y de gran interés, y lo siguen siendo.

\tex trabaja en conjunto con otro lenguaje, llamado \textit{Metafont}. El cual genera los glifos que usa el mismo.

El sistema funciona con una serie de instrucciones \textit{commands}, precedidos por una barra invertida (\textit{backslash}) y agrupaciones entre llaves. La base del lenguaje comprende de alrededor de 300 instrucciones, llamadas \textit{primitives}, que no son usadas por usuarios, dado que son instrucciones de bajo nivel. Por lo tanto, se crearon un conjunto de instrucciones basadas en estas para subir el nivel del lenguaje.

A pesar de ello, \tex es considerado difícil de aprender, contradiciendo el hecho de decir que es un sistema para que cualquiera genere documentos; por ello se han creado macro paquetes como \latex y Con\TeX t. Ademas de ello, se han implementado interfaces gráficas que se apoyan en \tex y hacen el lenguaje mas amigable para el usuario en general.

la salida del lenguaje es un archivo \textit{DVI}, \textit{PS} o \textit{PDF}, dependiendo de que hará con el documento generado.

\subparagraph{\latex}por su lado, es un lenguaje de marcado e incorpora a lenguaje anfitrión, \tex, una serie de instrucciones, ambientes y formatos predefinidos para aliviar la carga de entender \tex. Usando la misma filosofía de un lenguaje de marcado descriptivo, separa el contenido de la presentación, enfocándose mas en la estructura de un documento. E igualmente puede generar varias salidas.

La estructura basica de un archivo \latex, seria asi:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    \documentclass[options]{clase_del_documento}
    % Comandos del preambulo, si se necesitan 

    \begin{document}
    % Texto del documento e instrucciones

    \begin{ambiente1}
    % Instrucciones y texto del ambiente 1
    \end{ambiente1}

    % Mas texto del documento e instrucciones

    \begin{ambiente2}
    % Instrucciones y texto del ambiente 2
    \end{ambiente2}

    \end{document}
\end{lstlisting}
\end{minipage}
\end{center}

\section{\ruby}

\ruby es un lenguaje orientado a objetos ``puro'', dinámico, reflexivo y de propósito general. Surgió en el año 1995 en Japón, diseñado por \textit{Yukihiro Matsumoto}. Influenciado por Perl, Eiffel, Ada, Lisp y principalmente Smalltalk, por su sistema de objetos, donde todo elemento dentro del lenguaje es un objeto, inclusive las clases y elementos que otros lenguajes ven como literales (enteros, booleanos, caracteres, etc).

Es un lenguaje que brinda una sintaxis (similar a Perl), flexible y concisa, por lo tanto el código es limpio, enfocándose en lo que se quiere expresar y brinda la facilidad de crear lenguajes de dominio especifico. También, tiene la filosofía de que todo es una expresión y todo es ejecutado de manera imperativa. Por otro lado, tiene capacidad de introspección y reflexividad de objetos, facilitando el uso de meta-programación. Usa el modelo de referencia para las variables, y tiene recolección de basura. Ademas de que incorpora características funcionales, gracias a su flexibilidad.

\section{Racc}

Racc es un generador de \textit{parsers} LALR(1), escrito en \ruby y genera un programa \ruby. Esta herramienta toma como entrada una gramatica libre de contexto, en notacion \textit{Backus-Naur} y crea un \textit{parser} LALR\footnote{Los \textit{parsers} LALR, se refieren a LALR(1)}, el cual reconoce el lenguaje definido en la gramatica. Este tipo de \textit{parser} fueron inventados por \textit{Frank DeRemer}, partiendo de los \textit{parsers swift-reduce} LR(k) (\textit{left-right}) definidos por \textit{Donald Knuth}, que eran considerablemente mas extensos en cuanto al tamaño, en su época, para su implementación. Por lo que, fue una alternativa eficiente en cuanto a memoria. El primero y mas popular es \textit{Yacc}, y hoy en día muchos de los \textit{parsers} estan inspirados en el, como Racc.

\section{Git}

Herramienta para el control de versiones de un proyecto, usado en el desarrollo de software. Ofrece la posibilidad de crear una bitácora no lineal durante el desarrollo de un proyecto, usada para la colaboración de grupos grandes al mismo tiempo, a través de un sistema de unión (\textit{merge}) y derivación (\textit{branch}) del proyecto en un servidor privado o publico (como GitHub o Bitbucket); ó localmente.

\section{PDF}

Es un acrónimo en ingles, que significa, ``formato de documento portable'' (\textit{Portable Document Format}). El cual almacena toda la inofrmación de un documento, incluyendo el texto, fuente, imagenes y cualquier elemento que se necesite mostrar. Este formato, usa en parte al lenguaje \textit{PostScript} para generar el diseño del documento, ademas de presentar simplicidad y mejoras del mismo.

\section{TeX Live}

TeX Live es un software para adquirir el sistema tipografico \tex, junto a los archivos bnarios para su uso en ambientes Unix, como GNU/Linux. Incluye gran parte de los programas relacionados con \tex, macro paquetes y soporte. Ademas, posee un manejador de paquetes, que mantiene actualizado todos los componentes de \tex. Ofrece la posibilidad distintos esquemas de instalación, o escoger que paquetes se desean instalar.

La idea de usar este herramienta, es apoyar y facilitar el proceso de traducción incorporando una software existente.

\section{MiKTeX}

Esta herramienta es muy similar a Tex Live, pero esta desarrollada para funcionar solo en ambiente Windows. Pero una de las funcionalidades mas relevantes y que no esta presente en TeX Live, es la instalación automática de paquetes no instalados (cuando no se encuentre por \tex).

\section{Shell Script}

Es un programa diseñado para ejecutarse en un \textit{Shell} de Unix. Sus capacidades mas usadas son la manipulación de archivos, ejecución de programas e imprimir texto en la linea de comandos. Es llamado un lenguaje de programación de \textit{scripting}, en el caso de que se cree un archivo con un conjunto de instrucciones, va ejecutando cada una mientras lee el archivo desde arriba a abajo.

\subsection{Batch File}

En Windows existe algo similar, los archivos \textit{Batch}, que consiste en un conjunto de instrucciones, guardadas en un archivo y son ejecutadas por la linea de comandos. 

\chapter{Desarrollo}
En principio se ideo la posibilidad de que el lenguaje fuese no mas que una
librería de un lenguaje orientado a objetos que tradujese a \latex, pero esto
limitaría las características y posibilidades al momento de generar documentos.
Es evidente que el lenguaje limitara el poder de \latex, pero se quiere evitar
en mayor porcentaje dicha perdida y tener una interfaz lo suficientemente
flexible para abarcar las cualidades necesarias para la generación de documentos.

También se pensó en implementar un herramienta que tradujese a \latex
directamente, evitando intermediarios y se descarto esta posibilidad. Aunque es
totalmente factible, y un des-ligamiento de otro lenguaje (ademas de \latex),
representaría una mejora considerablemente en el rendimiento, pero sería un
trabajo extenso para la demostración de un concepto, cuando la idea es comprobar
que es posible reducir la dificultad de aprendizaje, sin perder flexibilidad de
manejar documentos, ademas de los elementos tipográficos, como objetos
referenciables, elevando el nivel de abstracción; y no simplemente como
elementos ordenados secuencialmente enmarcados.

Existen herramientas que tienen distintos enfoques al momento de la composición
tipográfica, y siguen distintas filosofías al momento de procesar texto. Dos de
ellas son \textit{WYSIWYG} (``\textit{what you see is what you get}'') y
\textit{WYSIWYM} (``\textit{what you see is what you mean}''). \lyx y 
\tex/\latex usan estas filosofías respectivamente. En este caso no están
desligados uno del otro, dado que \lyx ofrece una interfaz donde muestra lo que
sería el documento generado, pero se sigue escribiendo \latex, siendo
simplemente una fachada para interactuar directamente con el contenido sin
llegar a la semántica para generar dicho elemento tipográfico.

En este caso, no tiene sentido que nuestro lenguaje haga lo mismo que
\lyx. Por eso sigue la filosofía \textit{WYSIWYM}, pero incrementando la
facilidad de comprender el significado semántico de lo que se escribe.
Abstrayendo los elementos de un documento a objetos y encapsulando el texto con
su formato.

Ahora, la primera decisión tomada en cuanto a la sintaxis fue que en el diseño,
el lenguaje no debe hacer uso de marcas (\textit{tags}) para enmarcar un
comportamiento, ambiente o formato de texto. Este puede ir intrínseco en cada
objeto del documento, con ayuda de una estructuración adecuada, símbolos y
jerarquía.

Gran parte del lenguaje es inspirado en \ruby, y esto se debe a la filosofía que
posee el mismo como lenguaje orientado a objetos. Se necesitaba que nuestro
lenguaje tuviese un sistema de objetos que fuese puro, es decir, que todo es un
objeto y enfocarlo a lo que sería la estructuración de un documento.

Por otra parte, se quería reducir la dificultad de aprendizaje, al momento de
entender (leer) y generar (escribir) un documento. Para ello, se tomo en
consideración un concepto en computación para el empaquetamiento de información,
llamado serialización. Implementado por un lenguaje ampliamente usado, que es
JSON. Ademas de eso, los objetos en el lenguaje deben contener información sobre
el estilo ó formato (\textit{style}) del mismo, y por este motivo se decidió
tomar en consideración a CSS.

Juntando estos dos conceptos para encapsular en un objeto, la información,
estructura o texto, junto a su formato (estilo) y al final, la estructura del
documento sea una secuencia de objetos.

\section[OhTeX como un lenguaje embebido]{\ohtex como un lenguaje embebido}

Una de la sediciones mas relevantes de este lenguaje es que sea usado a través
de otro lenguaje, que en este caso es \ruby. Aunque, es posible implementarlo en
otro lenguaje, esta decisión es fundamentada en el hecho de que el modelo de las
variables, alcance y las asociaciones son las mismas que \ruby. Pero estas
características serán usadas para un propósito especifico y así, se reduce el
nivel de trabajo, en cuanto a la implementación del lenguaje.

A pesar de que el lenguaje posea su propia sintaxis, cada expresión guardaría un
símil prácticamente directo a una expresión en \ruby. Por lo tanto, \ohtex sería
un lenguaje de dominio especifico embebido (externo) en \ruby.

\section{Herramienta de composición tipográfica}

Existen muchos lenguajes para la composición tipográfica, con distintos
propósitos, características, flexibilidades, expresividad, áreas de uso, etc.
Este lenguaje tiene un propósito académico, es decir, generar documentos
académicos y de investigación, por ello se necesita usar una herramienta que sea
diseñada para ese fin. Por lo tanto, \latex es la opción mas adecuada, y ademas,
se estaría elevando el nivel de abstracción de un lenguaje poderoso pero difícil
de entender. Evidentemente, esto genera una perdida de flexibilidad en cuanto a
las posibilidades de generar un elemento tipográfico pero se abarcarían gran
parte de los mas usadas y relevantes para la creación de un documento completo.

También, esta decisión es tomada porque al momento del diseño de \latex, su
creador no se enfocó en reducir la dificultad de aprendizaje, solo en la libertad
de manejar elementos tipográficos a discreción y generar documentos hermosos;
pero todo ese poder no debe implicar una gran complejidad en lo que sería
entender el lenguaje.

\section{Entrada y Salida}

En cuanto a la incorporación de instrucciones para el manejo de entrada y salida
(\textit{I/O}), no existirán en el lenguaje. La única salida posible del
lenguaje será para generar un documento, haciendo uso de un operador que se
especificara en el próximo capítulo. Y esto es porque, no limita ni brinda poder
para el propósito final del lenguaje.

\section{Clases e Instancias}

Tomando en cuenta a \latex y \ruby donde es posible definir un clase de documento
(\textit{documentclass}) y una clase (\textit{class}) respectivamente, es este
lenguaje también se pueden definir clases que tienen una estructura similar a
las de \ruby pero tienen un significado semántico similar a las clases en \latex. En la mayoría de los casos, se usaran las clases para definir un nuevo sub-clase de la clase
abstracta \textit{Document}, donde se definirá un formato especifico de un documento en particular, que no pueda usar las clases predefinidas. En cualquier otro caso, todo clase que se defina sin un padre, sera sub-clase de la clase mayor \textit{Object}, siguiendo la filosofía de \ruby. Posteriormente se mostrara la sintaxis adecuada.

Todo clase puede definir atributos, que serán siempre públicos; al igual que todas las clases predefinidas en el lenguaje y ademas, la definición de instrucciones usando la sintaxis adecuada.

\subsection{Instancias}

Ahora, con respecto a la instanciación de una clase, en la mayoría de los
lenguajes orientados a objetos podemos notar que exista una palabra reservada o
método \textit{new} para la construcción de instancias, en otros casos la
llamada a un método con el mismo nombre de la clase es suficiente. Pero en
nuestro caso, se utiliza el símbolo doble dos-puntos (\texttt{::}) para
indicar la clase que se esta instanciando, junto al identificador que referencia
a dicha instancia y a los argumentos que serán pasados al constructor. Dichos
argumentos serán pasados por nombre, siguiendo el concepto de serialización de
datos.

\section{Inicialización y Asignación}

Al momento de construir una instancia de clase, los parámetros para inicializarla son pasados de una manera particular, solo para la construcción. Y esto es para aumentar la expresividad al momento de crear un objeto, tanto para quien lo escribe como quien lo lea. Por ello, se decidió que fuese una inicialización por nombre, seguida de su valor.

Aunque, el símbolo que representara esta ``asignación" ó ``inicialización" tuvo las siguientes opciones:

\begin{center}
\begin{enumerate}[label=Opción \alph*:, leftmargin=7em]
    \item (\texttt{=})
    \item (\texttt{:=})
    \item (\texttt{:})
    \item (\texttt{<-})
\end{enumerate}
\end{center}

Y se tenían que tomar en cuenta las siguientes consideraciones, para que al momento de leer la expresión tuviese un significado completo y concreto:

\begin{itemize}
\item El símbolo se va a escribir seguido, por lo tanto debe poseer la menor
      cantidad de caracteres posible, es decir, uno.
\item El símbolo debe referir a la asociación de un atributo con un valor
\item El símbolo debe poseer una semántica acorde a lo que se desea expresar.
\end{itemize}

En primer lugar descartamos al símbolo (\texttt{:=}), dado que es tedioso de escribir y representa una una sustitución textual, lo cual no es acorde a la semántica.

También el símbolo (\texttt{<-}) fue descartado, mas que todo porque su significado no es lo que busca decir la expresión. Este nos dice que sacara ``algo'' de la expresión derecha y lo colocara en la expresión izquierda.

Ahora los únicos símbolos que quedan son, (\texttt{=}) y (\texttt{:}). Y en la decisión final se opto por (\texttt{:}), tomando en cuenta las siguientes razones:

\begin{itemize}
\item Desde un punto de vista lingüístico, representa una pausa para hacer un llamado de atención en lo que sigue y que siempre esta relacionado con el texto precedente.
\item Cuando tenemos una expresión, <<\texttt{font : 10pt}>>. El lado izquierdo nos habla del lado derecho y eso es lo que quiere expresar.
\item También, es usados como lo hace CSS (un lenguaje de markup) y JSON (un lenguaje de serialización de datos)
\end{itemize}

En cuanto al simbolo ``igual'' (\texttt{=}), a pesar de que el símbolo (\texttt{:}) representa la inicialización de un
atributo de un objeto al momento de su construcción, el símbolo de asignación es
(\texttt{=}).

\section{Delimitadores y Secuenciación}

En este aspecto, existían tres opciones, la delimitación de algún alcance, ya
sea una definición de clase, un constructor, una función o estructura de control,
podría ser a través de indentación, la palabra reservada ``\textit{end}'' ó llaves
\ttcode{\{\}}. Se escogió esta ultima, porque sería asociación directa con CSS,
el formato y estilo del texto. Por otro lado, la secuenciación de instrucciones,
expresiones y objetos sera por medio del salto de linea; adicional a eso, se puede
usar el punto-y-coma para el mismo fin. Permitiendo así, dar la posibilidad de
escribir expresiones en una sola linea (\textit{inline}) o en bloque.

%\section{Tipos de Datos}

%El lenguaje manejará tipos enteros, booleanos, clases, instancias de clases, metodos y instrucciones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capitulo. OhTeX
%

\chapter[OhTeX]{\ohtex}

\ohtex es un lenguaje de programación de dominio específico, imperativo,
destinado a la composición tipográfica y orientado a objetos. En el diseño del
lenguaje se tienen elementos comúnmente usados en los lenguajes de programación,
así como estructuras de datos, estructuras de control, funciones,
procedimientos, etc.

\ohtex es un lenguaje de dominio especifico (\textit{DSL}) externo, es decir,
que tiene su propia sintaxis, embebido en \ruby. Esta decisión fue tomada porque
\ruby es un lenguaje orientado a objetos y así, todo el trabajo que conlleva el
manejo de objetos en el lenguaje, el alcance dinámico y el modelo de referencia
son realizados por \ruby. Además, el mismo crea un ambiente propicio para creación de
\textit{DSLs}, haciéndolo el mejor candidato para la implementación de \ohtex.

Ahora, considerando la composición tipográfica, se tomo en cuenta a \latex como
herramienta para la generación y estructuración del texto, exportado en
\textit{PDF}, que sería el producto final, es decir, un documento. Por lo tanto,
\ohtex es un traductor (compilador) de \ruby a \latex, demostrando que un
documento puede ser abstraído a un nivel mas alto y mantener una filosofía de
generar documentos bonitos, de propósito académico y al mismo tiempo poseer una sintaxis compresible.

El proceso de traducción seria así:

\begin{center}
    \ohtex $\longrightarrow$ \ruby $\longrightarrow$ \latex $\longrightarrow$ PDF
\end{center}

\section[Estructura de un archivo OhTeX]{Estructura de un archivo \ohtex}

Un archivo de \ohtex puede tener definiciones, instancias, estructuras de control, generar documentos, etc; o ninguna de ellas. No es necesario definir un método \textit{main} para que sea un programa válido.

Estructura de un programa \ohtex:

\begin{center}
%\begin{minipage}{\linewidth}
\begin{lstlisting}
    use <paquete>

    <documento> :: <clase_documento> {
        <atributo> : <valor> 
    }

    <instancia1> :: <clase> {
        ...
    }

    <instancia2> :: <clase>

    if <condicion> {
        ...
    } else {
        ...
    }

    <documento> << <instancia1>

    <documento> >> '<nombre_archivo>'
\end{lstlisting}
%\end{minipage}
\end{center}

Durante toda la ejecución del programa, en el archivo pueden crearse $n$
objetos, pero eso no le indica al lenguaje que esos $n$ objetos estarán
presentes en un documento o no, si es que se decide exportar alguno.

Por lo tanto, un programa en \ohtex puede contener $n$ objetos sin generar una salida pero ya se habría un chequeado lexicográfico, sintáctico y contextual del mismo.

\section{Ejecución}

La herramienta comienza leyendo de arriba a abajo, interpretando, creando
objetos, interactuando con los mismo y al final puede o no generar uno o mas
documentos. <<\textit{Crear un objeto no implica que el mismo estará en un
documento}>>.

\subsection{Linea de comandos}

La ejecución de la herramienta, se hace a través de la linea de comando y tiene las siguiente opciones:

{\footnotesize
    
\begin{tabular}{ l l l p{6cm} }
ohtex & [OPTION] \ldots \ FILE & & \\
      & - -tex-command=CMD & & especify the TeX command to compile \\
      & - -ruby-command=CMD & & especify the Ruby command to use \\
      & - -output-directory=DIR & & use a existing DIR as the directory to write files in \\
      \hline
      & -a, - -all & & generate all the TeX output files on each case (aux, dvi, log, out, ps, toc). \\
      & - -aux & & generate the aux output file of TeX \\
      & - -dvi & & generate the dvi output file of TeX \\
      & - -log & & generate the log output file of TeX \\
      & - -out & & generate the out output file of TeX \\
      & - -ps & & generate the ps output file of TeX \\
      & - -toc & & generate the toc output file of TeX \\
      \hline
      & - -help & & prints this help \\
      & - -version & & output version information and exit \\
\end{tabular}
}

\section{Paquetes e Inclusiones}

\subsection{Paquetes}

La palabra clave \texttt{use} es usada para indicarle a lenguaje cuales de los
paquetes de \latex se desean usar en cualquiera de los documentos que se vayan a
generar. Ciertos paquetes poseen una azúcar sintáctica en \ohtex y otros no, en este ultimo caso igualmente se puede usar el paquete pero debe usarse con un \textit{verbatim} de \latex, que posteriormente se especificara como se hace. Algunos de los paquetes exigen cero (opcionales) o mas parámetros; en
cualquiera de los casos, la sintaxis para el pase de parámetros es por nombre-valor, de manera secuencial, sin orden; 
como se muestra a continuación:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Paquetes},label=pkgs]
    use babel { lang : english }
    use microtype { potrusion : true; expasion : true }
    use geometry {
        paper      : letter
        left       : 1in
        right      : 1in
        top        : 1.5in
        headheight : 1in
        headsep    : 0.3in
    }
\end{lstlisting}
\end{minipage}
\end{center}

Por otro lado, se pueden especificar varios paquetes en una misma linea separados por espacios en blanco, eso
solo en el caso de que ninguno de los paquetes necesita parámetros, de la
siguiente manera:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    use amsmath amsfonts amsthm
\end{lstlisting}
\end{minipage}
\end{center}

Esto es, porque en ciertas ocasiones existen paquetes que viene en conjunto ó
tienen un propósito similar, ademas de la flexibilidad en cuanto a no escribir
repetidamente la palabra reservada \texttt{use}.

\subsection{Inclusiones}

En cuanto a la inclusiones, nos referimos a usar un archivo \ohtex que posea ciertos objetos de mi interés en desde otro archivo. Eso sería en el caso de que se decida agrupar un conjunto de instrucciones, clases, instancias; similares, con un mismo fin o arbitrarios, y que pueda usar en distintos archivos sin la necesidad de escribirlos nuevamente.

Para ello, se usa la palabra reservada \texttt{include}, seguido de un \textit{string}, con comillas simples, del nombre del archivo. Y así, todo objeto definido en dicho archivo estará en el alcance actual, cabe destacar que toda inclusión debe ser realizada al principio del cada archivo, sino sera considerado un error.

\section{Lexicografía}

\subsection{Identificadores}

Cada identificador es un nombre que se usa para referir a una variable, método,
comando, o paquete. 

De igual manera a como se permite en \ruby y la mayoría de los lenguajes, los
identificadores constan de caracteres alfanuméricos (\verb|a-zA-Z0-9|) y
underscores (\_), pero sin que comience por numero y que comience siempre por
minúscula. También está permitido, que los identificadores de los métodos puedan
terminar en interrogación (?), exclamación (!) ó igual (=). Sin restricciones
en la longitud del identificador. Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    foo
    bar
    baz
    this_is_my_4er_id
\end{lstlisting}
\end{minipage}
\end{center}

Por otro lado, existen ciertas palabras reservadas que no podrán ser usadas como
identificar en ningún caso. Las cuales se listan mas adelante.

\subsection{Comentarios}

Los comentarios de linea serán a partir de dos puntos seguidos \ttcode{..} hasta
el salto de linea (sin incluirlo). En caso de que desee incluir el salto de
linea en el comentario se deben usar tres puntos seguidos \ttcode{...}. Por
ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    .. esta linea no hace nada

    a = 5 .. ``a" es una variable local inicializada con 5

    a = 2 + ... esto es mas util con expresiones largas
        3
\end{lstlisting}
\end{minipage}
\end{center}

Los comentarios de bloque son a partir de dos puntos y una llave que abre
\ttcode{..\{\}} hasta una llave que cierra seguida de dos puntos \ttcode{\}..}. Por
ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    ..{
        Todo lo que se encuentre dentro de este bloque sera
        ignorado. El uso de comentarios de bloques anidados
        esta permitido para facilidad del programador,
        ..{
            asi que es posible hacerlo.
        }..
    }..    
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Palabras reservadas}

La siguientes palabras están reservadas en \ohtex:

\begin{center}
\ttfamily
\begin{tabular}{ l l l l l }
and & break & case & class & else \\
elsif & false & for & cmd & if \\
nil & or & return & self & super \\
true & use & when & while & in \\
\end{tabular}
\end{center}

\subsection{Expresiones}

Al igual que en \ruby (dado que es un lenguaje embebido), todo es una expresión.
La secuenciación es dada por los saltos de linea y el punto-y-coma (``;").

\section{Variables y Literales}

\ohtex, al ser un lenguaje embebido en \ruby, mantiene un símil en ciertos
aspectos de su sintaxis, así como su alcance y declaración de variables. De
alguna manera, es predecible, pero eso ayuda a reducir el tiempo de aprendizaje
y brinda la posibilidad de generar programas intuitivamente, enfocándose
esencialmente en la objetivo final, generar un documento con una excelente
composición tipográfica de manera estructural.

\subsection{Variables globales}

Toda variable que comience con dolar \ttcode{\$} tiene alcance global, dicha
variable puede ser accesada en cualquier momento de la ejecución desde cualquier
lugar. Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    $foo
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Variables locales}

Una variable local es aquella que comienza con un letra en minúsculas (a-z) o
underscore (\_). O una llamada a un método. Ademas dicha variable sera asequible
en el alcance donde fue declarada, exclusivamente.

\subsection{Variables de instancia}

Las variables de instancia son definidas usando la palabra reservada \texttt{attr} y son referidas por medio un arroba \texttt{@}.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    @bar
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Variables de clase}

Las variables de clase son definidas igualmente como se hace en \ruby, usando doble arroba \texttt{@@}. Y pueden ser accedidas desde cualquier instancia.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    @@baz
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Pseudo variables}

Las pseudo variables disponibles en \ohtex son:

\begin{itemize}
    \item \texttt{self}. Siendo un lenguaje orientado a objetos, debe existir una variable que refiera al objeto actual.
    \item \texttt{nil}. Representa a nulo o a nada.
    \item \texttt{true}. Representa a la verdad
    \item \texttt{false}. Representa a la falsedad.
\end{itemize}

\section{Formato de texto}

En esta sección se describen varios aspectos para darle un formato especifico al
texto, se podrá ver que existe una similitud con `Markdown` y eso es para
brindar facilidad cuando se genera un programa.

\subsection{Tamaño de fuente}

En \latex se permiten tres tamaño de fuente (por puntos [pt]) para el documento, pero puede formatearse una sección o texto en particular con las siguientes instrucciones:

\begin{center}
\begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill} }  l  l  l  l  }
    Comando   &          10pt &    11pt    & 12pt \\
    \hline
    \verb$\tiny$          &     5     &  6     &  6 \\
    \hline
    \verb$\scriptsize$    &     7     &  8     &  8 \\
    \hline
    \verb$\footnotesize$  &     8     &  9     &  10 \\
    \hline
    \verb$\small$         &     9     &  10    &  10.95 \\
    \hline
    \verb$\normalsize$    &     10    &  10.95 &  12 \\
    \hline
    \verb$\large$         &     12    &  12    &  14.4 \\
    \hline
    \verb$\Large$         &     14.4  &  14.4  &  17.28 \\
    \hline
    \verb$\LARGE$         &     17.28 &  17.28 &  20.74 \\
    \hline
    \verb$\huge$          &     20.74 &  20.74 &  24.88 \\
    \hline
    \verb$\Huge$          &     24.88 &  24.88 &  24.88 \\
    \hline
\end{tabular*}
\end{center}

Estas instrucciones son aceptados dentro de un string, usando la misma sintaxis de \latex, como si se estuviese escribiendo directamente. Esto es porque se considera que es son útiles y expresivos. Y cada punto sigue el standard norte americano de 1\textit{pt} es equivalente a 0.35136\textit{mm}.

\section{Familia de fuente}

En cuanto a la familia de la fuente, existen tres y cada una con ciertas fuentes que pueden usarse. Aquí se muestra una tabla con las opciones que vienen por defecto en \latex, por ende en \ohtex:

\begin{center}
\begin{tabular}{ c l }
    \hline
    \multicolumn{2}{c}{Fuentes \textit{Serif}} \\
    \hline
    cmr & Computer Modern Roman (default) \\
    lmr & Latin Modern Roman \\
    pbk & Bookman \\
    bch & Charter \\
    pnc & New Century Schoolbook \\
    ppl & Palatino \\
    ptm & Times \\
    \hline
    \multicolumn{2}{c}{Fuentes \textit{Sans Serif}} \\
    \hline
    cmss & Computer Modern Sans Serif (default) \\
    lmss & Latin Modern Sans Serif \\
    pag  & Avant Garde \\
    phv  & Helvetica \\
    \hline
    \multicolumn{2}{c}{Fuentes \textit{Typewriter}} \\
    \hline
    cmtt & Computer Modern Typewriter (default) \\
    lmtt & Latin Modern \\
    pcr  & Courier \\
    \hline
\end{tabular}
\end{center}

En el caso de \ohtex, para especificar otra fuente, distintas a la que viene por defecto en cada familia, se usa la siguiente sintaxis:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    doc :: Article {
        font-family   : rm .. puede ser 'sf' o 'tt'
        font-typeface : ptm
    }
\end{lstlisting}
\end{minipage}
\end{center}

Si la fuente que se escogió no pertenece a la familia, se lanzara un mensaje de error. En caso de que no se especifique la familia pero si la fuente, la misma será inferida y si solo se especifica la familia, se usara la fuente por defecto.

\subsection{Cursiva}

Para cambiar el formato de algún texto en especifico, el mismo debe estar entre
dos asteriscos \ttcode{*}, sin espacio al principio y sin saltos de linea. O simplemente se usa la instrucción de \latex \verb$\emph$

%Siguiendo la siguiente expresión regular en \ruby:
%
%\begin{center}
%\begin{verbatim}
    %/(\*\p{Graph}+\*|\*\p{Graph}+[\p{Graph} ]*\*)/
%\end{verbatim}
%\end{center}

\subsection{Negrita}

Similar a la sección anterior, se debe agrupar el texto, pero dentro de cuatro
asteriscos `*`, dos de cada lado del texto y siguiendo las mismas restricciones. Pudiendo usar la instrucción \verb$\textbf$

%\begin{center}
%\begin{verbatim}
    %/(\*\*\p{Graph}+\*\*|\*\*\p{Graph}+[\p{Graph} ]*\*\*)/
%\end{verbatim}
%\end{center}

\section{Literales}

Los literales son una notación para representar un valor en bajo nivel, y en este lenguaje, como en la mayoría, es existen literales para números, booleanos, string y estructuras como arreglos, tablas de hash (diccionarios) y rangos.

\subsection{Numeros}

Los números en \ohtex son representados en arábico, y pueden interpretarse como enteros o flotantes. Se considera que la precisión de los números puede mantenerse sencilla, dado que no es relevante, como lo sería en un lenguaje destinado al calculo numérico o metodos numéricos que requieren manejar la precisión de punto flotante.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    i = 9   .. Entero
    f = 4.2 .. Flotante
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Strings}

Un \textit{string} comienza y termina con una comilla simple \ttcode{'}, y puede estar sujeto a la interpolación de una expresión. Como el siguiente ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    s = 'Hola Mundo'
    i = 'Tengo ${3 + 6} manzanas'
\end{lstlisting}
\end{minipage}
\end{center}

El uso de comillas dobles no es permitido, y todo carácter que se escrito dentro de un \textit{string} se considerará de forma literal, es decir, que no existe notación con \textit{backslash}, excepto para `\verb$\'$' y `\verb$\\$'.

\subsection{Arreglos}

Los arreglos en \ohtex son ``heterogéneos'', dado que todo es un objeto, en todo momento los arreglos son de objetos. Para la definición de un nuevo arreglo se puede usar la notación de doble dos-puntos o con elementos separados por coma simple entre corchetes.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    array1 :: Array

    array2 = [3,6,9]

    .. acceso por indice
    array2[0] .. 3
    .. acceso por indice negativo
    array2[-1] .. 9
    .. sub arreglo usando rangos
    array2[0..1] .. [3,6] 
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Tablas de Hash}

Conocidos también como diccionarios, son estructuras que almacenan pares de objetos, una llave y su valor. Y los valores son accedidos por su llave, que debe ser única.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    hash1 :: Hash

    hash2 = {
        'foo' : 9
        'bar' : 27
        'baz' : 42
    }

    hash3 = { 'foo' : 9; 'bar' : 27; 'baz' : 42 }

    .. acceso por llave
    hash2['bar'] .. 27
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Rangos}

Son la representación de un subconjunto de valores posibles de los enteros (solo se pueden usar para esta clase), incluyendo los extremos.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    1..9
    -5..5

    9..0 .. sintacticamente es valido, pero genera un rango
         .. vacio
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Unidades de tamaño y formato de texto}

Cuando hablamos del formato de un texto, existen medidas a lo largo de todo el documento, tamaño de letra, espacio entre lineas o párrafos y esto se logra con unidades de medida.

\begin{tabular}{ r | l}
pt & un punto \\
\hline
mm & un milímetro  \\
\hline
cm & un centímetro  \\
\hline
in & una pulgada \\
\hline
ex & depende de la fuente actual \\
\hline
em & depende de la fuente actual \\
\hline
\end{tabular}

Y es posible usar estas unidades en atributos que lo permitan, y deben ser precedidas por un numero (entero o flotante).

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    doc.font = 11pt
    
    text.resize 1.5em
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Verbatim}

En ciertas ocasiones se desea hacer uso explicito de una expresión que sea literal en \ruby ó \latex, pero cabe destacar que el uso código literal en \ruby esta sujeto a que se decidió implementar el lenguaje en el mismo y su objetivo es flexibilizar el manejo de objeto y estructuras en el momento de que \ohtex no pueda, porque en cierto momento podría no estar implementado y se usaría como un respaldo. En el la implementación final no existiría.

En cuanto a una expresión literal de \latex, será posible introducirla en un documento, en cualquier momento de la ejecución, porque \ohtex abarca aspectos y funcionalidades comunes, pero ciertamente existen elementos tipográficos específicos que hasta el momento son soportados. Por esto, mientras no exista una sintaxis en el lenguaje para ello, es posible incorporarlo a mano en el documento.

Cualquier código que sea escrito dentro de las llaves podrá usar los objetos de
archivo definidos en \ohtex u otro verbatim de \ruby.

\ruby:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
&ruby {
    ... código ruby
}
\end{lstlisting}
\end{minipage}
\end{center}

\LaTeX:

En el caso de \latex es mas simple, solamente se debe incorporar el código entre
comillas simples al documento, haciendo uso del operador \textit{insert} (\verb$<<$). Haciendo
distinción entre el preámbulo y los elementos dentro del documento.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    ...

    doc1 :: Article {
        ...
    }

    .. código ohtex

    doc1.preamble << '
        \newcommand{cmd}[1]{Un Macro - #1}
    '

    doc1.document << '
        \noindent
        párrafo...
    '
    ...
\end{lstlisting}
\end{minipage}
\end{center}

Podría usarse el operador (\verb$<<$) para introducir código directamente al documento sin especificarlo y si no se quisiera especificar explícitamente que se agregara algo al preámbulo, se puede usar el operador (\verb$<<<$) que solo opera con clases derivada de \texttt{Document}. Claramente lo errores que puedan ser generados por esta incorporación de código a mano, quedan por parte del programador.

\section{Operadores}

\subsection{Asignación}

Ya se un identificar u objeto, el símbolo de asignación es el igual (\texttt{=}) por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    var = 'Hola Mundo'
    int = 27
\end{lstlisting}
\end{minipage}
\end{center}

Es posible realizar una auto-asignación, con todo objeto que tenga las instrucciones, (\texttt{+}), (\texttt{-}), (\texttt{*}), (\texttt{**}) o (\texttt{/}). Dependiendo de la operación que se desea realizar.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    foo = 9
    foo += 18
    foo -= 6
    foo *= 2
    foo **= 3
    foo /= 1764  
\end{lstlisting}
\end{minipage}
\end{center}

Cabe destacar que los operadores aritméticos (\texttt{+}), (\texttt{-}), (\texttt{*}), (\texttt{**}) o (\texttt{/}) no son operadores en \ohtex, son instrucciones.

\subsection{Lógicos}

Al igual que los operadores aritméticos, los operadores lógicos (\texttt{<}), (\texttt{>}), (\texttt{<=}), (\texttt{>=}), (\texttt{==}), (\texttt{!=}) y (\texttt{!}) son instrucciones, dependiendo de cada objeto.

Pero en \ohtex, existen los operadores \texttt{and} y \texttt{or}, que corresponden a la conjunción y disyunción respectivamente.

\section{Estructuras de Control}

\subsection{Condicionales}

\subsubsection{Condicional \textit{if}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    i = 9

    if i < 10 {
        i *= i
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{Condicional \textit{if-elsif-else}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    if <condicion> {
        ...
    } elsif <condicion> {
        ...
    } else {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{Condicional \textit{case-when}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    i = 27
    case i {
        when 25    : i = 'Igual a 25'
        when 1..20 :
            i = 'Dentro de rango'
            i += ' (1..20)'
        when 0     : i = 'Igual a 0'
        else       : .. no pasa nada
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Bucles}

\subsubsection{\textit{while}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    while <condicion> {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{\textit{for}}

La declaración de un \texttt{for}, se usa para iterar sobre estructuras de una manera mas cómoda, sin preocuparse por aumentar un contador.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    for <variable_local> in <rango/arreglo/hash> {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

En el caso especial de una tabla de hash, se usan dos variables, una que itera sobre las llaves y otro que itera sobre los valores, respectivos uno con el otro. Si se quisiera iterar solamente sobre las llaves o los valores, debe decirse explícitamente.

Si en algún momento se quiere detener algún tipo de bucle, se debe usar la palabra reservada \texttt{break}.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    for llave in my_hash.keys {
        ...
    }

    for valor in my_hash.values {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

%\subsection{Manejo de excepciones}

\section{Instrucciones}

En \ohtex, existe el concepto de híbrido entre los métodos y funciones con las instrucciones de \latex; donde hay un identificador, parámetros o aridad, un alcance y posiblemente un valor de retorno o no. Se hace uso de la palabra reservada \texttt{cmd} para indicar una nueva declaración o sobre-escritura de un comando. Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    cmd foo(a, b) { .. los parentesis son opcionales
        return a + b
    }

    cmd foo 2 { .. la definición anterior es sobre-escrita
        return #1 + #2
    }
\end{lstlisting}
\end{minipage}
\end{center}

Las instrucciones pueden representar algo complejo como un metodo o algo tan simple como un macro, al final pueden ser representados de igual manera pero tienen una finalidad distinta.

\section{Clases}

\subsection{Definición de clase}

Para definir una clase nueva, se debe comenzar con la palabra reservada \texttt{class}, seguida del nombre de mi nueva clase (el cual debe comenzar con mayúscula).

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    class $\langle$nombre_de_la_clase$\rangle$ {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Atributos}

Todo atributo que se defina en una clase sera publico (variables de instancia) y no existe la posibilidad de que sean privados o protegidos. Referenciar a un atributo desde un comando se hará similar a \ruby, poniendo de prefijo un arroba \ttcode{@} o se puede omitir si no es opacado por un parámetro con el mismo nombre, pero es recomendable usar el arroba para saber de que estamos hablando de una variable de instancia.

Para definir los atributos de mi instancia se usa la palabra reservada \texttt{attr}, seguido uno o mas identificadores separados por coma, por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    class A {
        attr a, b

        cmd foo {
            return @a + @b
        }
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{Variable de clase}

La variables de clase, siempre serán privadas, a menos que se definan un \textit{getter} y/o \textit{setter}. Estas pueden ser definidas en cualquier momento de la definición de clase (con tan solo escribirla).

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    class B {
        @@var_class = 27

        cmd foo {
            ...
        }
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Instanciación}

Tomando en cuenta la estructura básica de un programa en \ohtex, en especifico
los \textit{dos-puntos} dobles (\texttt{::}), representa la instanciación de
una clase, es el constructor de objetos y la referencia a esa instancia es dada
por el nombre (identificador) del lado izquierdo (\textit{lhs}). Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    doc1 :: Article {
        ...
    }   
\end{lstlisting}
\end{minipage}
\end{center}

Si bien al construir un objeto, el mismo debe inicializarse (en el caso de que
sea necesario), dependiendo si tiene o no valores por defecto. Y para ello, se
usan las llaves, donde se encierra una secuencia (puede ser vacía) de
identificadores que representan algunos (o todos) los atributos del objeto, cada
nombre es seguido del símbolo \textit{dos-puntos} (\texttt{:}) y luego el valor
que inicializará el atributo; cada una de estas inicializaciones es separada por
salto de linea (\verb|\n|) o por punto-y-coma (\texttt{;}). Aquí se muestra una
inicialización (\textit{singleton}):

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    font : 10pt
\end{lstlisting}
\end{minipage}
\end{center}

%\subsection{Declaración de visibilidad}

\subsection{Herencia}

En el caso de que se desee especificar una clase padre, se usa el simbolo menor-que (\texttt{<}) seguido de la clase padre y entre llaves estarán definidos los atributos y instrucciones.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    class $\langle$nombre_de_la_clase$\rangle$ < $\langle$clase_padre$\rangle$ {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

Cabe destacar que la herencia es simple, todo clase solo puede tener un padre.

\section{Estructuración del documento}

La estructura de un documento \latex, esta dividida en partes, capítulos, secciones, sub-secciones, sub-sub-secciones, párrafos y sub-párrafos. En \ohtex existe una clase para cada una de estas divisiones, haciendo la estructura como un árbol (mas parecida a un índice), en vez de forma secuencial.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    ohtex :: Chapter {
        ...
    }

    estruccturacion :: Section {
        ...
    }

    ohtex << estruccturacion

    ...
\end{lstlisting}
\end{minipage}
\end{center}

\chapter{Conclusiones y Recomendaciones}

Luego de diseñar un lenguaje orientado a objetos destinado a la composición tipográfica, es factible decir que el marcado de un contenido es posible a través de abstracción y jerarquía de elementos tipográficos tratados como objetos no secuenciales; para la posterior generación de un documento presentable, con un diseño de calidad. Es razonable decir, que existe una perdida de flexibilidad, en cuanto a las posibilidades de cambiar el formato del contenido, pero se abarcan una gran parte de esas cualidades para obtener un nivel de flexibilidad considerable. Por otro lado, \tex posee una gran flexibilidad pero es complicado de aprender, así que toda esa amplia posibilidad de formatos no son comprendidas, solo después de un tiempo considerable y en muchas ocasiones, el tiempo no sobra y la disposición no es suficiente; y al final, se desea que sea un sistema accesible a quien lo desee y amigable al usuario.

En este trabajo se uso \ruby como lenguaje de apoyo, para tener un sistema de objetos acorde a los requerimientos y sería recomendable eliminar ese intermediario en el proceso de traducción. En este caso, no representa un problema porque la idea era ilustrar un concepto, mas no crear una herramienta de uso industrial pero podría considerarse en el momento de que se desee implementar de manera eficiente y de uso regular. Y se tomarían en consideración cambios en el diseño, siempre manteniendo consistencia en el lenguaje.

Por otro lado, el uso de \latex como herramienta de composición tipográfica esta basado en su aceptación general, gran flexibilidad y soporte. Pero dado que existe otro alternativo derivada de \tex, que es Con\TeX t, debería plantearse la posibilidad de integrarla con \ohtex, ya sea en sustitución de \latex o como complemento. Aunque trabajar con \tex directamente no sería una decisión ligera de tomar pero podría ser ideal.

\end{document}