\documentclass[12pt,letterpaper,titlepage,oneside,openright]{book}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[svgnames]{xcolor}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{lettrine}
\usepackage{listings}
\usepackage{relsize}
\usepackage{xspace}
%\usepackage{tabularx}
%\usepackage{booktabs}
%\usepackage{cleveref}
%\usepackage{microtype}
%\usepackage{geometry}
%\usepackage{nag}
%\usepackage{siunitx}

\newcommand{\OhTeX}{%
    \makebox[0.76em][c]{O}%
    \makebox[0.25em][c]{%
        \raisebox{0.14em}[0em][0em]{%
            \fontsize{0.5em}{0cm}%
                \selectfont H%
        }%
    }%
    \makebox[1.35em][c]{\TeX}%
}

% Change title of every code listing
\renewcommand*\lstlistingname{Código}
% Code listing options
\lstset{
basicstyle=\footnotesize\ttfamily,
%numbers=left,
%numberstyle=\scriptsize,
%numbersep=1pt,
belowskip=\medskipamount,
frame = trBL,%single,
framexleftmargin=15pt,
literate={á}{{\'a}}1 {í}{{\'i}}1 {é}{{\'e}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1,
}

\renewcommand*\rmdefault{ptm} % Times Font
\renewcommand{\labelitemi}{$\bullet$} % List symbol

% Add a space a the end of the original logo
\newcommand{\latex}{\LaTeX\xspace}
\newcommand{\tex}{\TeX\xspace}
\newcommand{\ohtex}{\OhTeX\xspace}
\newcommand{\ruby}{\textit{Ruby}\xspace}
\newcommand{\lyx}{\textit{LyX}\xspace}

% Reduce hyphenation
\hyphenpenalty 1000
\exhyphenpenalty 1000

\setlength{\parindent}{3em} % First line paragraph indentation
\setlength{\parskip}{2em} % Paragraph spacing
\renewcommand{\baselinestretch}{1.3} % Line spacing
%1.0    single spacing
%1.3    one-and-a-half spacing
%1.6    double spacing

\setcounter{chapter}{0} % Chapter begins on chapter -1

\newcommand{\nonumberchapter}[1]{
    \chapter*{#1}
    \addcontentsline{toc}{chapter}{#1}
}

\newcommand{\myref}[5]{
    #1. #2. #3. Disponible en Internet: #4, consultado el #5.

% Huerta, Ana. 2003. El gabinete de Historia Natural de Puebla. Disponible en Internet: http://www.elementos.buap.mx/num48/htm/17.htm, consultado el 25 de Abril de 2008.
}

\newcommand{\ttcode}[1]{(\texttt{#1})}

\title{\ohtex \ : Un lenguaje de programación orientado a objetos destinado a la composición tipográfica}
\author{Lilue, David}

\begin{document}

\frontmatter

\maketitle

\nonumberchapter{Preámbulo}

\section*{Resumen}

\lettrine[lines=2]{D}{}\ urante la década de los $70'$ se creó un lenguaje llamado \textit{troff} qué fue inspirado por
runoff, el primer programa para el formato de texto qué fue desarrollado a mediados
de los 60'. \textit{troff} posee la cualidad de de indicar fuente, espaciados,
párrafos, márgenes, pie de páginas, posicionar caracteres de manera arbitraria en las
páginas, superponerlas, entre otras cosas. Aunque hoy en día existen lenguajes para
la composición tipográfica que son comúnmente usados, como \LaTeX \ y otros lenguajes de
markup, este sigue siendo usado ampliamente para la documentación de UNIX. Por otro
lado en los años 90' se re-implementado como \textit{groff} por los sistemas GNU, por
cuestiones de software libre. 

Un aspecto importante, es para quién está destinado este lenguaje de composición
tipográfica, es decir, para una comunidad científica y de investigación, para la
comunidad literaria, para una comunidad administrativa y/o gerencial o todas? 

Existen muchos lenguajes de Markup, unos que son simples, otros que son más
complejos, así como \textit{markdown} y \LaTeX, respectivamente. Uno trata de
simplificar y el otro trata de generar un documento enfocado en la belleza. Tomando
en cuenta que se desea la posibilidad de generar documentos similares a los de latex,
pero que sea tan sencillo cómo un lenguaje de markup ligero (LML). Dándole un punto
de vista más estructural y abstracto, haciendo uso de la orientación a objetos.

La idea con este lenguaje es poder manejar de una manera abstracta y simple, los
elementos de un documento así como su composición tipográfica en el documento final
generado. Por lo tanto, será posible usar estructuras de control para generar
distintos documentos a partir de objetos y estructuras abstractas.

% Por ejemplo, agarrar una plantilla con espacios vacíos iterar sobre una lista de
% objetos dónde cada objeto llene de manera diferente y sus espacios vacíos. Sería
% como una meta programación de documentos.

\newpage
 
%\addcontentsline{toc}{chapter}{Dedicatoria}
\section*{} % Dedicatoria
\begin{flushright}
Para todos esos artistas que dejaron su obra, \\ sin su nombre y aun así trascendieron.
\end{flushright}

\newpage

%\addcontentsline{toc}{chapter}{Agradecimientos}
\section*{} % Agradecimientos
\begin{flushleft}
Agradezco a un perro de papel \\
que algunos dicen que esta perdido, \\
mas no quiere ser encontrado.
\end{flushleft}

\newpage

\tableofcontents

\mainmatter

%\thispagestyle{empty} % Removes the page numbering.

%\listoffigures

%\pagebreak
 
%\listoftables
 
%\newpage

%\pagenumbering{arabic} % Re-start the page numbering with arabic style.

%\chapter{Motivación}
\chapter{Introducción}
\section{Antecedentes}
La composición tipográfica es un termino que se maneja desde alrededores del año 1040, refiriéndose
a la estructura del texto ordenando \textit{types} (una pieza que represente una letra o
símbolo) acorde a la ortografía de un lenguaje y al final, obtener la visualización de un texto.

Al principio, se tenían piezas movibles que se ordenaban a mano (dichas piezas estaban al revés 
para que saliesen bien orientadas al imprimir) y se imprimían pagina por pagina. Todo esta 
metodología para la composición tipográfica se inicio en china con piezas de cerámica, 
posteriormente se usaron piezas de metal (bronce). Esta tecnología de impresión llego a Europa
en el siglo 15 y era usada principalmente para cartas.

Para el siglo 19, se había globalizado e industrializado esta forma de impresión, mas que todo por
imprentas y editoriales, gracias a la maquina linotipia (\textit{Linotype Machine}). Estas mismas duraron hasta las ultimas décadas del siglo 20, dado que fueron sustituidas por una nueva tecnología llamada foto-composición, que hacia uso programas para la composición tipográfica electrónica como \textit{troff} y un \textit{phototypesetter} (\textit{CAT}).  A pesar de su innovación, se convirtió rápidamente en un método obsoleto gracias a avanzados lenguajes de composición tipográfica como:

\begin{itemize}
\item ditroff (1979)
\item \TeX \ (1979)
\item \LaTeX \ (1981-1983)
\end{itemize}

\subsection{Linea de Tiempo}

\begin{itemize}

\item 1971, Graphic Systems designs and markets the C/A/T phototypesetter.
\item 1972, Graphic Systems provides a simple computer front end to handle display typesetting from text input using a standard set of fonts.
\item 1973, Bell Laboratories purchases a GSI C/A/T phototypesetter for their UNIX software development team.
\item 1973, The troff software was created by Joe F. Ossanna at Bell Labs.
\item 1974, Graphic Systems partners with Singer Corporation to market the GSI C/A/T phototypesetter. Singer Corporation was allowed to put the Singer C/A/T logo on equipment they sold.
\item 1978, Singer Corporation gets out of the typesetting business.
\item 1978, Wang Laboratories purchases Graphic Systems and continued to market the GSI C/A/T typesetter. for UNIX based phototypesetting. The phototypesetter was then known as the Wang Graphic Systems C/A/T. This allowed the phototypesetter to be available through the 1980s.
\item 1979, ditroff software was created by Brian Kernighan.
\item 1979, TeX software was created by Donald E. Knuth.
\item 1981-1983, LaTeX software was created by Leslie Lamport.
\item 1992, Wang Laboratories declared Chapter 11 bankruptcy.
\end{itemize}

\subsection{\textit{troff}}
\subsection{\TeX}
\subsection{\LaTeX}
\subsection[OhTeX]{\ohtex}

\chapter{Marco Teórico}
\section{Composición Tipográfica (\textit{Typesetting})}
\section{Programación orientada a objetos (\textit{OOP})}
\section{Lenguajes de \textit{Markup}}
\section{Serialización de datos}
\section{Leanguajes de dominio específico (\textit{DSLs})}

\chapter{Marco Tecnológico}

\chapter{Desarrollo}
En principio se ideo la posibilidad de que el lenguaje fuese no mas que una
librería de un lenguaje orientado a objetos que tradujese a \latex, pero esto
limitaría las características y posibilidades al momento de generar documentos.
Es evidente que el lenguaje limitara el poder de \latex, pero se quiere evitar
en mayor porcentaje dicha perdida y tener una interfaz lo suficientemente
flexible para abarcar las cualidades necesarias para la generación de documentos.

También se pensó en implementar un herramienta que tradujese a \latex
directamente, evitando intermediarios y se descarto esta posibilidad. Aunque es
totalmente factible, y un des-ligamiento de otro lenguaje (ademas de \latex),
representaría una mejora considerablemente en el rendimiento, pero sería un
trabajo extenso para la demostración de un concepto, cuando la idea es comprobar
que es posible reducir la dificultad de aprendizaje, sin perder flexibilidad de
manejar documentos, ademas de los elementos tipográficos, como objetos
referenciables, elevando el nivel de abstracción; y no simplemente como
elementos ordenados secuencialmente enmarcados.

Existen herramientas que tienen distintos enfoques al momento de la composición
tipográfica, y siguen distintas filosofías al momento de procesar texto. Dos de
ellas son \textit{WYSIWYG} (``\textit{what you see is what you get}'') y
\textit{WYSIWYM} (``\textit{what you see is what you mean}''). \lyx y 
\tex/\latex usan estas filosofías respectivamente. En este caso no están
desligados uno del otro, dado que \lyx ofrece una interfaz donde muestra lo que
sería el documento generado, pero se sigue escribiendo \latex, siendo
simplemente una fachada para interactuar directamente con el contenido sin
llegar a la semántica para generar dicho elemento tipográfico.

En este caso, no tiene sentido que nuestro lenguaje haga lo mismo que
\lyx. Por eso sigue la filosofía \textit{WYSIWYM}, pero incrementando la
facilidad de comprender el significado semántico de lo que se escribe.
Abstrayendo los elementos de un documento a objetos y encapsulando el texto con
su formato.

Ahora, la primera decisión tomada en cuanto a la sintaxis fue que en el diseño,
el lenguaje no debe hacer uso de marcas (\textit{tags}) para enmarcar un
comportamiento, ambiente o formato de texto. Este puede ir intrínseco en cada
objeto del documento, con ayuda de una estructuración adecuada, símbolos y
jerarquía.

Gran parte del lenguaje es inspirado en \ruby, y esto se debe a la filosofia que
posee el mismo como lenguaje orientado a objetos. Se necesitaba que nuestro
lenguaje tuviese un sistema de objetos que fuese puro, es decir, que todo es un
objeto y enfocarlo a lo que sería la estructuración de un documento.

Por otra parte, se quería reducir la dificultad de aprendizaje, al momento de
entender (leer) y generar (escribir) un documento. Para ello, se tomo en
consideración un concepto en computación para el empaquetamiento de información,
llamado serialización. Implementado por un lenguaje ampliamente usado, que es
JSON. Ademas de eso, los objetos en el lenguaje deben contener información sobre
el estilo ó formato (\textit{style}) del mismo, y por este motivo se decidió
tomar en consideración a CSS.

Juntando estos dos conceptos para encapsular en un objeto, la información,
estructura o texto, junto a su formato (estilo) y al final, la estructura del
documento sea una secuencia de objetos.

\section[OhTeX como un lenguaje embebido]{\ohtex como un lenguaje embebido}

Una de la sediciones mas relevantes de este lenguaje es que sea usado a través
de otro lenguaje, que en este caso es \ruby. Aunque, es posible implementarlo en
otro lenguaje, esta decisión es fundamentada en el hecho de que el modelo de las
variables, alcance y las asociaciones son las mismas que \ruby. Pero estas
características serán usadas para un propósito especifico y así, se reduce el
nivel de trabajo, en cuanto a la implementación del lenguaje.

A pesar de que el lenguaje posea su propia sintaxis, cada expresión guardaría un
símil prácticamente directo a una expresión en \ruby. Por lo tanto, \ohtex sería
un lenguaje de dominio especifico embebido (externo) en \ruby.

\section{Herramienta de composición tipográfica}

Existen muchos lenguajes para la composición tipográfica, con distintos
propósitos, características, flexibilidades, expresividad, áreas de uso, etc.
Este lenguaje tiene un propósito académico, es decir, generar documentos
académicos y de investigación, por ello se necesita usar una herramienta que sea
diseñada para ese fin. Por lo tanto, \latex es la opción mas adecuada, y ademas,
se estaría elevando el nivel de abstracción de un lenguaje poderoso pero difícil
de entender. Evidentemente, esto genera una perdida de flexibilidad en cuanto a
las posibilidades de generar un elemento tipográfico pero se abarcarían gran
parte de los mas usadas y relevantes para la creación de un documento completo.

También, esta decisión es tomada porque al momento del diseño de \latex, su
creador no se enfocó en reducir la dificultad de aprendizaje, solo en la libertad
de manejar elementos tipográficos a discreción y generar documentos hermosos;
pero todo ese poder no debe implicar una gran complejidad en lo que sería
entender el lenguaje.

\section{Entrada y Salida}

En cuanto a la incorporación de instrucciones para el manejo de entrada y salida
(\textit{I/O}), no existirán en el lenguaje. La unica salida posible del
lenguaje será para generar un documento, haciendo uso de un operador que se
especificara en el proximo capítulo. Y esto es porque, no limita ni brinda poder
para el proposito final del lenguaje.

\section{Clases e Instancias}

Tomando en cuenta a \latex y \ruby donde es posible definir un clase de documento
(\textit{documentclass}) y una clase (\textit{class}) respectivamente, es este
lenguaje también se pueden definir clases que tienen una estructura similar a
las de \ruby pero tienen un significado semántico similar a las clases en \latex. En la mayoría de los casos, se usaran las clases para definir un nuevo sub-clase de la clase
abstracta \textit{Document}, donde se definirá un formato especifico de un documento en particular, que no pueda usar las clases predefinidas. En cualquier otro caso, todo clase que se defina sin un padre, sera sub-clase de la clase mayor \textit{Object}, siguiendo la filosofía de \ruby. Posteriormente se mostrara la sintaxis adecuada.

Todo clase puede definir atributos, que serán siempre públicos; al igual que todas las clases predefinidas en el lenguaje y ademas, la definición de funciones y comandos usando la sintaxis adecuada.

\subsection{Instancias}

Ahora, con respecto a la instanciación de una clase, en la mayoría de los
lenguajes orientados a objetos podemos notar que exista una palabra reservada o
método \textit{new} para la construcción de instancias, en otros casos la
llamada a un método con el mismo nombre de la clase es suficiente. Pero en
nuestro caso, se utiliza el símbolo doble dos-puntos (\texttt{::}) para
indicar la clase que se esta instanciando, junto al identificador que referencia
a dicha instancia y a los argumentos que serán pasados al constructor. Dichos
argumentos serán pasados por nombre, siguiendo el concepto de serialización de
datos.

\section{Inicialización y Asignación}

Al momento de construir una instancia de clase, los parametros para inicializarla son pasados de una manera particular, solo para la construcción. Y esto es para aumentar la expresividad al momento de crear un objeto, tanto para quien lo escribe como quien lo lea. Por ello, se decidió que fuese una inicialización por nombre, seguida de su valor.

Aunque, el simbolo que representara esta ``asignación" ó ``inicialización" tuvo las siguientes opciones:

\begin{center}
\begin{enumerate}[label=Opción \alph*:, leftmargin=7em]
    \item (\texttt{=})
    \item (\texttt{:=})
    \item (\texttt{:})
    \item (\texttt{<-})
\end{enumerate}
\end{center}

Y se tenían que tomar en cuenta las siguientes consideraciones, para que al momento de leer la expresión tuviese un significado completo y concreto:

\begin{itemize}
\item El símbolo se va a escribir seguido, por lo tanto debe poseer la menor
      cantidad de caracteres posible, es decir, uno.
\item El símbolo debe referir a la asociación de un atributo con un valor
\item El símbolo debe poseer una semántica acorde a lo que se desea expresar.
\end{itemize}

En primer lugar descartamos al simbolo (\texttt{:=}), dado que es tedioso de escribir y representa una una sustitución textual, lo cual no es acorde a la semantica.

Tambien el simbolo (\texttt{<-}) fue descartado, mas que todo porque su significado no es lo que busca decir la expresion. Este nos dice que sacara ``algo'' de la expresion derecha y lo colocara en la expresion izquierda.

Ahora los unicos simbolos que quedan son, (\texttt{=}) y (\texttt{:}). Y en la decisión final se opto por (\texttt{:}), tomando en cuenta las siguientes razones:

\begin{itemize}
\item Desde un punto de vista lingüístico, representa una pausa para hacer un llamado de atención en lo que sigue y que siempre esta relacionado con el texto precedente.
\item Cuando tenemos una expresión, <<\texttt{font : 10pt}>>. El lado izquierdo nos habla del lado derecho y eso es lo que quiere expresar.
\item Tambien, es usados como lo hace CSS (un lenguaje de markup) y JSON (un lenguaje de serialización de datos)
\end{itemize}

En cuanto al simbolo ``igual'' (\texttt{=}), a pesar de que el símbolo (\texttt{:}) representa la inicialización de un
atributo de un objeto al momento de su construcción, el símbolo de asignación es
(\texttt{=}).

\section{Delimitadores y Secuenciación}

En este aspecto, existían tres opciones, la delimitación de algún alcance, ya
sea una definición de clase, un constructor, una función o estructura de control,
podría ser a través de indentación, la palabra reservada ``\textit{end}'' ó llaves
\ttcode{\{\}}. Se escogió esta ultima, porque sería asociación directa con CSS,
el formato y estilo del texto. Por otro lado, la secuenciación de instrucciones,
expresiones y objetos sera por medio del salto de linea; adicional a eso, se puede
usar el punto-y-coma para el mismo fin. Permitiendo así, dar la posibilidad de
escribir expresiones en una sola linea (\textit{inline}) o en bloque.

%\section{Tipos de Datos}

%El lenguaje manejará tipos enteros, booleanos, clases, instancias de clases, metodos y comandos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capitulo. OhTeX
%

\chapter[OhTeX]{\ohtex}

\ohtex es un lenguaje de programación de dominio específico, imperativo,
destinado a la composición tipográfica y orientado a objetos. En el diseño del
lenguaje se tienen elementos comúnmente usados en los lenguajes de programación,
así como estructuras de datos, estructuras de control, funciones,
procedimientos, etc.

\ohtex es un lenguaje de dominio especifico (\textit{DSL}) externo, es decir,
que tiene su propia sintaxis, embebido en \ruby. Esta decisión fue tomada porque
\ruby es un lenguaje orientado a objetos y así, todo el trabajo que conlleva el
manejo de objetos en el lenguaje, el alcance dinámico y el modelo de referencia
son realizados por \ruby. Además, el mismo crea un ambiente propicio para creación de
\textit{DSLs}, haciéndolo el mejor candidato para la implementación de \ohtex.

Ahora, considerando la composición tipográfica, se tomo en cuenta a \latex como
herramienta para la generación y estructuración del texto, exportado en
\textit{PDF}, que sería el producto final, es decir, un documento. Por lo tanto,
\ohtex es un traductor (compilador) de \ruby a \latex, demostrando que un
documento puede ser abstraído a un nivel mas alto y mantener una filosofía de
generar documentos bonitos, de propósito académico y al mismo tiempo poseer una sintaxis compresible.

El proceso de traducción seria así:

\begin{center}
    \ohtex $\longrightarrow$ \ruby $\longrightarrow$ \latex $\longrightarrow$ PDF
\end{center}

\section[Estructura de un archivo OhTeX]{Estructura de un archivo \ohtex}

Un archivo de \ohtex puede tener definiciones, instancias, estructuras de control, generar documentos, etc; o ninguna de ellas. No es necesario definir un método \textit{main} para que sea un programa válido.

Estructura de un programa \ohtex:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    use <paquete>

    <documento> :: <clase_documento> {
        <atributo> : <valor> 
    }

    <instancia1> :: <clase> {
        ...
    }

    <instancia2> :: <clase>

    if <condicion> {
        ...
    } else {
        ...
    }

    <documento> << <instancia1>

    <documento> >> '<nombre_archivo>'
\end{lstlisting}
\end{minipage}
\end{center}

Durante toda la ejecución del programa, en el archivo pueden crearse $n$
objetos, pero eso no le indica al lenguaje que esos $n$ objetos estarán
presentes en un documento o no, si es que se decide exportar alguno.

Por lo tanto, un programa en \ohtex puede contener $n$ objetos sin generar una salida pero ya se habría un chequeado lexicógrafico, sintáctico y contextual del mismo. 

\section{Paquetes e Inclusiones}

\subsection{Paquetes}

La palabra clave \texttt{use} es usada para indicarle a lenguaje cuales de los
paquetes de \latex se desean usar en cualquiera de los documentos que se vayan a
generar. Ciertos paquetes poseen una azúcar sintactica en ohtex y otros no, en este ultimo caso igualmente se puede usar el paquete pero debe usarse con un \textit{verbatim} de \latex, que posteriormente se especificara como se hace. Algunos de los paquetes exigen cero (opcionales) o mas parámetros; en
cualquiera de los casos, la sintaxis para el pase de parámetros es por nombre-valor, de manera secuencial, sin orden; 
como se muestra a continuación:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Paquetes},label=pkgs]
    use babel { lang : english }
    use microtype { potrusion : true; expasion : true }
    use geometry {
        paper      : letter
        left       : 1in
        right      : 1in
        top        : 1.5in
        headheight : 1in
        headsep    : 0.3in
    }
\end{lstlisting}
\end{minipage}
\end{center}

Por otro lado, se pueden especificar varios paquetes en una misma linea separados por espacios en blanco, eso
solo en el caso de que ninguno de los paquetes necesita parámetros, de la
siguiente manera:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    use amsmath amsfonts amsthm
\end{lstlisting}
\end{minipage}
\end{center}

Esto es, porque en ciertas ocasiones existen paquetes que viene en conjunto ó
tienen un propósito similar, ademas de la flexibilidad en cuanto a no escribir
repetidamente la palabra reservada \texttt{use}.

\subsection{Inclusiones}

En cuanto a la inclusiones, nos referimos a usar un archivo \ohtex que posea ciertos objetos de mi interés en desde otro archivo. Eso sería en el caso de que haya decidido encapsular un conjunto de funciones, comandos, clases, instancias; similares, con un mismo fin o arbitrarios, y que pueda usar en distintos archivos sin la necesidad de escribirlos nuevamente.

Para ello, se usa la palabra reservada \texttt{include}, seguido de un \textit{string}, con comillas simples, del nombre del archivo. Y así, todo objeto definido en dicho archivo estará en el alcance actual, cabe destacar que toda inclusión debe ser realizada al principio del cada archivo, sinó sera considerado un error.

\subsection{Ejecución}

La herramienta comienza leyendo de arriba a abajo, interpretando, creando
objetos, interactuando con los mismo y al final puede o no generar uno o mas
documentos. <<\textit{Crear un objeto no implica que el mismo estará en un
documento}>>.

\section{Lexicografía}

\subsection{Identificadores}

Cada identificador es un nombre que se usa para referir a una variable, método,
comando, o paquete. 

De igual manera a como se permite en \ruby y la mayoría de los lenguajes, los
identificadores constan de caracteres alfanuméricos (\verb|a-zA-Z0-9|) y
underscores (\_), pero sin que comience por numero y que comience siempre por
minúscula. Tambien está permitido, que los identificadores de los métodos puedan
terminar en interrogación (?), exclamación (!) ó igual (=). Sin restricciones
en la longitud del identificador. Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    foo
    bar
    baz
    this_is_my_4er_id
\end{lstlisting}
\end{minipage}
\end{center}

Por otro lado, existen ciertas palabras reservadas que no podrán ser usadas como
identificar en ningún caso. Las cuales se listan mas adelante.

\subsection{Comentarios}

Los comentarios de linea serán a partir de dos puntos seguidos \ttcode{..} hasta
el salto de linea (sin incluirlo). En caso de que desee incluir el salto de
linea en el comentario se deben usar tres puntos seguidos \ttcode{...}. Por
ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    .. esta linea no hace nada

    a = 5 .. ``a" es una variable local inicializada con 5

    a = 2 + ... esto es mas util con expresiones largas
        3
\end{lstlisting}
\end{minipage}
\end{center}

Los comentarios de bloque son a partir de dos puntos y una llave que abre
\ttcode{..\{\}} hasta una llave que cierra seguida de dos puntos \ttcode{\}..}. Por
ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    ..{
        Todo lo que se encuentre dentro de este bloque sera
        ignorado. El uso de comentarios de bloques anidados
        esta permitido para facilidad del programador,
        ..{
            asi que es posible hacerlo.
        }..
    }..    
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Palabras reservadas}

La siguientes palabras están reservadas en \ohtex:

\begin{center}
\ttfamily
\begin{tabular}{ l l l l l }
and & break & case & class & do \\
else & elsif & false & for & fun \\
if & loop & nil & or & rescue \\
return & self & super & true & try \\
until & use & when & while & \\
\end{tabular}
\end{center}

\subsection{Expresiones}

Al igual que en \ruby (dado que es un lenguaje embebido), todo es una expresión.
La secuenciacion es dada por los saltos de linea y el punto-y-coma (``;").

\section{Variables y Literales}

\ohtex, al ser un lenguaje embebido en \ruby, mantiene un símil en ciertos
aspectos de su sintaxis, así como su alcance y declaración de variables. De
alguna manera, es predecible, pero eso ayuda a reducir el tiempo de aprendizaje
y brinda la posibilidad de generar programas intuitivamente, enfocándose
esencialmente en la objetivo final, generar un documento con una excelente
composición tipográfica de manera estructural.

\subsection{Variables globales}

Toda variable que comience con dolar \ttcode{\$} tiene alcance global, dicha
variable puede ser accesada en cualquier momento de la ejecución desde cualquier
lugar. Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    $foo
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Variables locales}

Una variable local es aquella que comienza con un letra en minúsculas (a-z) o
underscore (\_). O una llamada a un método. Ademas dicha variable sera asequible
en el alcance donde fue declarada, exclusivamente.

\subsection{Variables de instancia}

Las variables de instancia son definidas usando la palabra reservada \texttt{attr} y son referidas por medio un arroba \texttt{@}.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    @bar
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Variables de clase}

Las variables de clase son definidas igualmente como se hace en \ruby, usando doble arroba \texttt{@@}. Y pueden ser accedidas desde cualquier instancia.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    @@baz
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Pseudo variables}

Las pseudo variables disponibles en \ohtex son:

\begin{itemize}
    \item \texttt{self}. Siendo un lenguaje orientado a objetos, debe existir una variable que refiera al objeto actual.
    \item \texttt{nil}. Representa a nulo o a nada.
    \item \texttt{true}. Representa a la verdad
    \item \texttt{false}. Representa a la falsedad.
\end{itemize}

\section{Formato de texto}

En esta sección se describen varios aspectos para darle un formato especifico al
texto, se podrá ver que existe una similitud con `Markdown` y eso es para
brindar facilidad cuando se genera un programa.

\subsection{Tamaño de fuente}

En \latex se permiten tres tamaño de fuente (por puntos [pt]) para el documento, pero puede formatearse una sección o texto en particular con los siguientes comandos:

\begin{center}
\begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill} }  l  l  l  l  }
    Comando   &          10pt &    11pt    & 12pt \\
    \hline
    \verb$\tiny$          &     5     &  6     &  6 \\
    \hline
    \verb$\scriptsize$    &     7     &  8     &  8 \\
    \hline
    \verb$\footnotesize$  &     8     &  9     &  10 \\
    \hline
    \verb$\small$         &     9     &  10    &  10.95 \\
    \hline
    \verb$\normalsize$    &     10    &  10.95 &  12 \\
    \hline
    \verb$\large$         &     12    &  12    &  14.4 \\
    \hline
    \verb$\Large$         &     14.4  &  14.4  &  17.28 \\
    \hline
    \verb$\LARGE$         &     17.28 &  17.28 &  20.74 \\
    \hline
    \verb$\huge$          &     20.74 &  20.74 &  24.88 \\
    \hline
    \verb$\Huge$          &     24.88 &  24.88 &  24.88 \\
    \hline
\end{tabular*}
\end{center}

Estos comandos son aceptados dentro de un string, usando la misma sintaxis de \latex, como si se estuviese escribiendo directamente. Esto es porque se considera que es son útiles y expresivos. Y cada punto sigue el standard norte americano de 1\textit{pt} es equivalente a 0.35136\textit{mm}.

\section{Familia de fuente}

En cuanto a la familia de la fuente, existen tres y cada una con ciertas fuentes que pueden usarse. Aquí se muestra una tabla con las opciones que vienen por defecto en \latex, por ende en \ohtex:

\begin{center}
\begin{tabular}{ c l }
    \hline
    \multicolumn{2}{c}{Fuentes \textit{Serif}} \\
    \hline
    cmr & Computer Modern Roman (default) \\
    lmr & Latin Modern Roman \\
    pbk & Bookman \\
    bch & Charter \\
    pnc & New Century Schoolbook \\
    ppl & Palatino \\
    ptm & Times \\
    \hline
    \multicolumn{2}{c}{Fuentes \textit{Sans Serif}} \\
    \hline
    cmss & Computer Modern Sans Serif (default) \\
    lmss & Latin Modern Sans Serif \\
    pag  & Avant Garde \\
    phv  & Helvetica \\
    \hline
    \multicolumn{2}{c}{Fuentes \textit{Typewriter}} \\
    \hline
    cmtt & Computer Modern Typewriter (default) \\
    lmtt & Latin Modern \\
    pcr  & Courier \\
    \hline
\end{tabular}
\end{center}

En el caso de \ohtex, para especificar otra fuente, distintas a la que viene por defecto en cada familia, se usa la siguiente sintaxis:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    doc :: Article {
        font-family   : rm .. puede ser 'sf' o 'tt'
        font-typeface : ptm
    }
\end{lstlisting}
\end{minipage}
\end{center}

Si la fuente que se escogió no pertenece a la familia, se lanzara un mensaje de error. En caso de que no se especifique la familia pero si la fuente, la misma será inferida y si solo se especifica la familia, se usara la fuente por defecto.

\subsection{Cursiva}

Para cambiar el formato de algún texto en especifico, el mismo debe estar entre
dos asteriscos \ttcode{*}, sin espacio al principio y sin saltos de linea.

Siguiendo la siguiente expresión regular en \ruby:

\begin{center}
\begin{verbatim}
    /(\*\p{Graph}+\*|\*\p{Graph}+[\p{Graph} ]*\*)/
\end{verbatim}
\end{center}

\subsection{Negrita}

Similar a la sección anterior, se debe agrupar el texto, pero dentro de cuatro
asteriscos `*`, dos de cada lado del texto y siguiendo las mismas restricciones.

\begin{center}
\begin{verbatim}
    /(\*\*\p{Graph}+\*\*|\*\*\p{Graph}+[\p{Graph} ]*\*\*)/
\end{verbatim}
\end{center}

\section{Estructuración del documento}

\section{Literales}

Los literales son una notación para representar un valor en bajo nivel, y en este lenguaje, como en la mayoría, es existen literales para numeros, booleanos, string y estructuras como arreglos, tablas de hash (diccionarios) y rangos.

\subsection{Numeros}

Los numeros en \ohtex son representados en arábico, y pueden interpretarse como enteros o flotantes. Se considera que la precisión de los números puede mantenerse sencilla, dado que no es relevante, como lo sería en un lenguaje destinado al calculo numérico o metodos numéricos que requieren manejar la precisión de punto flotante.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    i = 9   .. Entero
    f = 4.2 .. Flotante
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Strings}

Un \textit{string} comienza y termina con una comilla simple \ttcode{'}, y puede estar sujeto a la interpolación de una expresion. Como el siguiente ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    s = 'Hola Mundo'
    i = 'Tengo ${3 + 6} manzanas'
\end{lstlisting}
\end{minipage}
\end{center}

El uso de comillas dobles no es permitido, y todo caracter que se escrito dentro de un \textit{string} se considerará de forma literal, es decir, que no existe notación con \textit{backslash}, excepto para `\verb$\'$' y `\verb$\\$'.

\subsection{Arreglos}

Los arreglos en \ohtex son ``heterogeneos'', dado que todo es un objeto, en todo momento los arreglos son de objetos. Para la definición de un nuevo arreglo se puede usar la notación de doble dos-puntos o con elementos separados por coma simple entre corchetes.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    array1 :: Array

    array2 = [3,6,9]

    .. acceso por indice
    array2[0] .. 3
    .. acceso por indice negativo
    array2[-1] .. 9
    .. sub arreglo usando rangos
    array2[0..1] .. [3,6] 
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Tablas de Hash}

Conocidos tambien como diccionarios, son estructuras que almacenan pares de objetos, una llave y su valor. Y los valores son accedidos por su llave, que debe ser única.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    hash1 :: Hash

    hash2 = {
        'foo' : 9
        'bar' : 27
        'baz' : 42
    }

    hash3 = { 'foo' : 9; 'bar' : 27; 'baz' : 42 }

    .. acceso por llave
    hash2['bar'] .. 27
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Rangos}

Son la representación de un subconjunto de valores posibles de los enteros (solo se pueden usar para esta clase), incluyendo los extremos.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    1..9
    -5..5

    9..0 .. sintacticamente es valido, pero genera un rango
         .. vacio
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Unidades de tamaño y formato de texto}

Cuando hablamos del formato de un texto, existen medidas a lo largo de todo el documento, tamaño de letra, espacio entre lineas o parrafos y esto se logra con unidades de medida.

\begin{tabular}{ r | l}
pt & un punto \\
\hline
mm & un milimetro  \\
\hline
cm & un centimetro  \\
\hline
in & una pulgada \\
\hline
ex & depende de la fuente actual \\
\hline
em & depende de la fuente actual \\
\hline
\end{tabular}

Y es posible usar estas unidades en atributos que lo permitan, y deben ser precedidas por un numero (entero o flotante).

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    doc.font = 11pt
    
    text.resize 1.5em
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Verbatim}

En ciertas ocasiones se desea hacer uso explicito de una expresión que sea literal en \ruby ó \latex, pero cabe destacar que el uso código literal en \ruby esta sujeto a que se decidió implementar el lenguaje en el mismo y su objetivo es flexibilizar el manejo de objeto y estructuras en el momento de que \ohtex no pueda, porque en cierto momento podría no estar implementado y se usaria como un respaldo. En el la implementación final no existiría.

En cuanto a una expresión literal de \latex, será posible introducirla en un documento, en cualquier momento de la ejecución, porque \ohtex abarca aspectos y funcionalidades comunes, pero ciertamente existen elementos tipograficos especificos que hasta el momento son soportados. Por esto, mientras no exista una sintaxis en el lenguaje para ello, es posible incorporarlo a mano en el documento.

Cualquier código que sea escrito dentro de las llaves podrá usar los objetos de
archivo definidos en \ohtex u otro verbatim de \ruby.

\ruby:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
&ruby {
    ... código ruby
}
\end{lstlisting}
\end{minipage}
\end{center}

\LaTeX:

En el caso de \latex es mas simple, solamente se debe incorporar el código entre
comillas simples al documento, haciendo uso del operador \textit{insert} (\verb$<<$). Haciendo
distinción entre el preámbulo y los elementos dentro del documento.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    ...

    doc1 :: Article {
        ...
    }

    .. código ohtex

    doc1.preamble << '
        \newcommand{cmd}[1]{Un Macro - #1}
    '

    doc1.document << '
        \noindent
        párrafo...
    '
    ...
\end{lstlisting}
\end{minipage}
\end{center}

Podria usarse el operador (\verb$<<$) para introducir codigo directamente al documento sin especificarlo y si no se quisiera especificar explicitamente que se agregara algo al preámbulo, se puede usar el operador (\verb$<<<$) que solo opera con clases derivada de \texttt{Document}. Claramente lo errores que puedan ser generados por esta incorporación de codigo a mano, quedan por parte del programador.

\section{Operadores}

\subsection{Asignación}

Ya se un identificar u objeto, el símbolo de asignación es el igual (\texttt{=}) por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    var = 'Hola Mundo'
    int = 27
\end{lstlisting}
\end{minipage}
\end{center}

Es posible realizar una auto-asignación, con todo objeto que tenga los comandos, (\texttt{+}), (\texttt{-}), (\texttt{*}), (\texttt{**}) o (\texttt{/}). Dependiendo de la operación que se desea realizar.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    foo = 9
    foo += 18
    foo -= 6
    foo *= 2
    foo **= 3
    foo /= 1764  
\end{lstlisting}
\end{minipage}
\end{center}

Cabe destacar que los operadores aritmeticos (\texttt{+}), (\texttt{-}), (\texttt{*}), (\texttt{**}) o (\texttt{/}) no son operadores en \ohtex, son comandos.

\subsection{Lógicos}

Al igual que los operadores aritmeticos, los operadores logicos (\texttt{<}), (\texttt{>}), (\texttt{<=}), (\texttt{>=}), (\texttt{==}), (\texttt{!=}) y (\texttt{!}) son comandos, dependiendo de cada objeto.

Pero en \ohtex, existen los operadores \texttt{and} y \texttt{or}, que corresponden a la conjunción y disyunción respectivamente.

\section{Estructuras de Control}

\subsection{Condicionales}

\subsubsection{Codicional \textit{if}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    i = 9

    if i < 10 {
        i *= i
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{Codicional \textit{if-elsif-else}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    if <condicion> {
        ...
    } elsif <condicion> {
        ...
    } else {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{Codicional \textit{case-when}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    i = 27
    case i {
        when 25    : i = 'Igual a 25'
        when 1..20 :
            i = 'Dentro de rango'
            i += ' (1..20)'
        when 0     : i = 'Igual a 0'
        else       : .. no pasa nada
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Bucles}

\subsubsection{\textit{while}}

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    while <condicion> {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{\textit{for}}

La declaración de un \texttt{for}, se usa para iterar sobre estructuras de una manera mas comoda, sin preocuparse por aumentar un contador.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    for <variable_local> in <rango/arreglo/hash> {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

En el caso especial de una tabla de hash, se usan dos varibles, una que itera sobre las llaves y otro que itera sobre los valores, respectivos uno con el otro. Si se quisiera iterar solamente sobre las llaves o los valores, debe decirse explícitamente.

Si en algún momento se quiere detener algun tipo de bucle, se debe usar la palabra reservada \texttt{break}.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    for llave in my_hash.keys {
        ...
    }

    for valor in my_hash.values {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

%\subsection{Manejo de excepciones}

\section{Comandos}

En \ohtex, existe el concepto de híbrido entre los metodos y funciones con los comandos de \latex; donde hay un identificador, parametros o aridad, un alcance y posiblemente un valor de retorno o no. Se hace uso de la palabra reservada \texttt{cmd} para indicar una nueva declaración o sobre-escritura de un comando. Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    cmd foo(a, b) { .. los parentesis son opcionales
        return a + b
    }

    cmd foo 2 { .. la definición anterior es sobre-escrita
        return #1 + #2
    }
\end{lstlisting}
\end{minipage}
\end{center}

Los comandos pueden representar algo complejo como un metodo o algo tan simple como un macro, al final pueden ser representados de igual manera pero tienen una finalidad distinta.

\section{Clases}

\subsection{Definición de clase}

Para definir una clase nueva, se debe comenzar con la palabra reservada \texttt{class}, seguida del nombre de mi nueva clase (el cual debe comenzar con mayúscula).

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    class $\langle$nombre_de_la_clase$\rangle$ {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Atributos}

Todo atributo que se defina en una clase sera publico (variables de instancia) y no existe la posibilidad de que sean privados o protegidos. Referenciar a un atributo desde un comando se hará similar a \ruby, poniendo de prefijo un arroba \ttcode{@} o se puede omitir si no es opacado por un parámetro con el mismo nombre, pero es recomendable usar el arroba para saber de que estamos hablando de una variable de instancia.

Para definir los atributos de mi instancia se usa la palabra reservada \texttt{attr}, seguido uno o mas identificadores separados por coma, por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    class A {
        attr a, b

        cmd foo {
            return @a + @b
        }
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsubsection{Variable de clase}

La variables de clase, siempre serán privadas, a menos que se definan un \textit{getter} y/o \textit{setter}. Estas pueden ser definidas en cualquier momento de la definición de clase (con tan solo escribirla).

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    class B {
        @@var_class = 27

        cmd foo {
            ...
        }
    }
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Instanciación}

Tomando en cuenta la estructura básica de un programa en \ohtex, en especifico
los \textit{dos-puntos} dobles (\texttt{::}), representa la instanciación de
una clase, es el constructor de objetos y la referencia a esa instancia es dada
por el nombre (identificador) del lado izquierdo (\textit{lhs}). Por ejemplo:

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    doc1 :: Article {
        ...
    }   
\end{lstlisting}
\end{minipage}
\end{center}

Si bien al construir un objeto, el mismo debe inicializarse (en el caso de que
sea necesario), dependiendo si tiene o no valores por defecto. Y para ello, se
usan las llaves, donde se encierra una secuencia (puede ser vacía) de
identificadores que representan algunos (o todos) los atributos del objeto, cada
nombre es seguido del símbolo \textit{dos-puntos} (\texttt{:}) y luego el valor
que inicializará el atributo; cada una de estas inicializaciones es separada por
salto de linea (\verb|\n|) o por punto-y-coma (\texttt{;}). Aquí se muestra una
inicialización (\textit{singleton}):

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}
    font : 10pt
\end{lstlisting}
\end{minipage}
\end{center}

%\subsection{Declaración de visibilidad}

\subsection{Herencia}

En el caso de que se desee especificar una clase padre, se usa el simbolo menor-que (\texttt{<}) seguido de la clase padre y entre llaves estarán definidos los atributos y comandos.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    class $\langle$nombre_de_la_clase$\rangle$ < $\langle$clase_padre$\rangle$ {
        ...
    }
\end{lstlisting}
\end{minipage}
\end{center}

\chapter{Conclusiones y Recomendaciones}
\end{document}